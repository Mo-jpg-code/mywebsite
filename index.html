<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Hide & Collect PRO</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222;
            color: #eee;
            margin: 0;
            padding: 10px;
            overscroll-behavior: none;
        }
        .controls {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .controls label { font-size: 0.9em; }
        .controls input[type="range"] { width: 120px; }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }
        canvas {
            border: 1px solid #555;
            background-color: #333;
            max-width: 100%;
            height: auto;
            display: block;
        }
        #gameCanvas { background-color: #405060; }
        #aiVisionCanvas { background-color: #444; }
        .stats {
            border: 1px solid #555;
            padding: 10px;
            background-color: #3a3a3a;
            width: calc(100% - 22px);
            max-width: 378px;
            box-sizing: border-box;
        }
        .stats p { margin: 5px 0; font-size: 0.85em; }
        h1, h2 { text-align: center; margin-top: 5px; margin-bottom: 10px; }
        h2 { font-size: 1.1em; }

        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                align-items: flex-start;
                max-width: 800px;
            }
            .game-area { flex: 2; }
            .ai-info { flex: 1; }
            .stats { width: auto; max-width: none; }
            .controls input[type="range"] { width: 150px; }
        }
    </style>
</head>
<body>
    <h1>AI Hide & Collect PRO (Bigger Brain)</h1>

    <div class="controls">
        <label for="speedControl">Sim Speed:</label>
        <input type="range" id="speedControl" min="10" max="500" value="75">
        <span id="speedValue">75</span> ms/step
    </div>

    <div class="container">
        <div class="game-area">
            <h2>Game World</h2>
            <canvas id="gameCanvas" width="300" height="450"></canvas>
        </div>
        <div class="ai-info">
            <h2>AI "Vision" (State)</h2>
            <canvas id="aiVisionCanvas" width="150" height="150"></canvas>
            <div class="stats">
                <h2>Stats</h2>
                <p>Episode: <span id="episode">0</span></p>
                <p>Cookies (Coins): <span id="cookies">0</span></p>
                <p>Punishments (Caught): <span id="punishments">0</span></p>
                <p>Epsilon: <span id="epsilon">1.000</span></p>
                <p>Last Action: <span id="lastAction">-</span></p>
                <p>Q-Table Size: <span id="qTableSize">0</span></p>
                <p>Max Steps: <span id="maxStepsInfo">0</span></p>
            </div>
        </div>
    </div>

    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const aiVisionCanvas = document.getElementById('aiVisionCanvas');
        const aiVisionCtx = aiVisionCanvas.getContext('2d');

        const episodeEl = document.getElementById('episode');
        const cookiesEl = document.getElementById('cookies');
        const punishmentsEl = document.getElementById('punishments');
        const epsilonEl = document.getElementById('epsilon');
        const lastActionEl = document.getElementById('lastAction');
        const qTableSizeEl = document.getElementById('qTableSize');
        const maxStepsInfoEl = document.getElementById('maxStepsInfo');

        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');

        // --- Game Constants ---
        const PLAYER_SIZE = 15;
        const HUNTER_SIZE = 15;
        const COIN_RADIUS = 7;
        const MOVE_SPEED = PLAYER_SIZE; // Move by its full size for clearer step counting
        let MAX_STEPS_PER_EPISODE = 400;

        // --- Game Objects ---
        let player = { x: 50, y: 50, width: PLAYER_SIZE, height: PLAYER_SIZE, color: 'blue' };
        let hunter = { x: gameCanvas.width - 50, y: gameCanvas.height - 50, width: HUNTER_SIZE, height: HUNTER_SIZE, color: 'red' };
        let coins = [];
        let obstacles = [ // More obstacles for complex scenarios
            { x: 100, y: 0, width: 20, height: 120, color: '#777' }, // Top wall
            { x: 100, y: gameCanvas.height - 120, width: 20, height: 120, color: '#777' }, // Bottom wall
            { x: 180, y: 200, width: 100, height: 20, color: '#777' }, // Mid bar
            { x: 0, y: gameCanvas.height/2 - 10, width: 70, height: 20, color: '#777' }, // Left bar
            { x: gameCanvas.width-70, y: gameCanvas.height/2 - 50, width: 70, height: 20, color: '#777' }, // Right bar
            { x: 50, y: 50, width: 20, height: 80, color: '#777' },
            { x: gameCanvas.width - 70, y: gameCanvas.height - 130, width: 20, height: 80, color: '#777' }
        ];

        // --- AI Q-Learning Parameters ---
        let qTable = {};
        const LEARNING_RATE = 0.1;
        const DISCOUNT_FACTOR = 0.9;
        let epsilon = 1.0;
        const EPSILON_DECAY = 0.9999; // Slower decay for larger state space
        const MIN_EPSILON = 0.1;    // Higher min epsilon for more exploration

        const ACTIONS = [
            { dx: 0, dy: -1, name: "Up" },   // dx/dy are multipliers for MOVE_SPEED
            { dx: 0, dy: 1, name: "Down" },
            { dx: -1, dy: 0, name: "Left" },
            { dx: 1, dy: 0, name: "Right" },
            { dx: 0, dy: 0, name: "Stay" }
        ];

        let scoreCookies = 0;
        let scorePunishments = 0;
        let episodeCount = 0;
        let currentSteps = 0;

        let simIntervalId = null;
        let currentSimSpeed = 75;

        // --- Helper Functions ---
        function rectCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function spawnCoin() {
            let coinX, coinY, validPosition;
            const maxAttempts = 50;
            let attempts = 0;
            do {
                validPosition = true;
                attempts++;
                coinX = COIN_RADIUS + Math.random() * (gameCanvas.width - 2 * COIN_RADIUS);
                coinY = COIN_RADIUS + Math.random() * (gameCanvas.height - 2 * COIN_RADIUS);
                const tempCoinCircle = { x: coinX, y: coinY, radius: COIN_RADIUS };

                for (const obs of obstacles) { // Check collision with obstacles
                    // Approximate obstacle as circle for simple distance check with coin
                    const obsCenterX = obs.x + obs.width / 2;
                    const obsCenterY = obs.y + obs.height / 2;
                    const distToObsCenter = Math.hypot(coinX - obsCenterX, coinY - obsCenterY);
                    if (distToObsCenter < COIN_RADIUS + Math.max(obs.width, obs.height) / 2) {
                         // More precise check: point in rect for coin center
                        if (coinX > obs.x && coinX < obs.x + obs.width && coinY > obs.y && coinY < obs.y + obs.height) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (!validPosition) continue;
                if (Math.hypot(coinX - (player.x+player.width/2), coinY - (player.y+player.height/2)) < PLAYER_SIZE * 2 + COIN_RADIUS) validPosition = false;
                if (Math.hypot(coinX - (hunter.x+hunter.width/2), coinY - (hunter.y+hunter.height/2)) < HUNTER_SIZE * 2 + COIN_RADIUS) validPosition = false;

            } while (!validPosition && attempts < maxAttempts);

            if (!validPosition) { // Fallback if too many attempts
                coinX = gameCanvas.width / 2;
                coinY = gameCanvas.height / 2;
            }
            coins = [{ x: coinX, y: coinY, radius: COIN_RADIUS, color: 'lime' }];
        }

        function getAngleCategory(dx, dy) {
            const angle = Math.atan2(dy, dx) + Math.PI;
            return Math.floor(angle / (Math.PI / 4)) % 8;
        }

        function getDistanceCategory(dist, entitySize) { // 4 categories
            if (dist < entitySize * 2) return 0; // Very Close
            if (dist < entitySize * 5) return 1; // Close
            if (dist < entitySize * 10) return 2; // Medium
            return 3; // Far
        }

        // Probes how many MOVE_SPEED steps are clear in a direction
        function probeClearSteps(entity, unitDirX, unitDirY, maxProbeSteps) {
            let clearSteps = 0;
            for (let i = 1; i <= maxProbeSteps; i++) {
                const nextX = entity.x + unitDirX * i * MOVE_SPEED;
                const nextY = entity.y + unitDirY * i * MOVE_SPEED;
                const probeRect = { x: nextX, y: nextY, width: entity.width, height: entity.height };

                if (probeRect.x < 0 || probeRect.x + probeRect.width > gameCanvas.width ||
                    probeRect.y < 0 || probeRect.y + probeRect.height > gameCanvas.height) {
                    break; // Hit boundary
                }
                let collision = false;
                for (const obs of obstacles) {
                    if (rectCollision(probeRect, obs)) {
                        collision = true;
                        break;
                    }
                }
                if (collision) break;
                clearSteps++;
            }
            // Discretize: 0, 1, 2 (for 2+ clear steps)
            if (clearSteps === 0) return 0;
            if (clearSteps === 1) return 1;
            return 2;
        }

        // Checks if a path (approximated by sampling player-sized rects) is clear
        function isPathClear(entity1, entity2, obstaclesArr, checkWidth, checkHeight) {
            const e1cx = entity1.x + entity1.width / 2;
            const e1cy = entity1.y + entity1.height / 2;
            const e2cx = entity2.x + (entity2.width || entity2.radius*2) / 2;
            const e2cy = entity2.y + (entity2.height || entity2.radius*2) / 2;

            const dx = e2cx - e1cx;
            const dy = e2cy - e1cy;
            const dist = Math.hypot(dx, dy);

            if (dist < PLAYER_SIZE/2) return true; // Essentially on top or very close

            const numSamples = Math.max(2, Math.ceil(dist / (PLAYER_SIZE / 2)));

            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const currentX = e1cx + t * dx;
                const currentY = e1cy + t * dy;

                const probeRect = {
                    x: currentX - checkWidth / 2,
                    y: currentY - checkHeight / 2,
                    width: checkWidth,
                    height: checkHeight
                };
                
                // Don't check collision with entity1 or entity2 themselves, only external obstacles
                // This is implicitly handled as we iterate over `obstaclesArr`
                for (const obs of obstaclesArr) {
                    if (rectCollision(probeRect, obs)) {
                        return false; // Path blocked by an obstacle
                    }
                }
            }
            return true; // Path clear
        }


        function getDiscretizedState() {
            // 1. Hunter relative to Player
            const relHx_center = (hunter.x + hunter.width/2) - (player.x + player.width/2);
            const relHy_center = (hunter.y + hunter.height/2) - (player.y + player.height/2);
            const hunterAngle = getAngleCategory(relHx_center, relHy_center);
            const hunterDist = getDistanceCategory(Math.hypot(relHx_center, relHy_center), PLAYER_SIZE);

            // 2. Coin relative to Player
            let coinAngle = 0, coinDist = 3; // Default (far) if no coin
            if (coins.length > 0) {
                const coin = coins[0];
                const relCx_center = coin.x - (player.x + player.width/2);
                const relCy_center = coin.y - (player.y + player.height/2);
                coinAngle = getAngleCategory(relCx_center, relCy_center);
                coinDist = getDistanceCategory(Math.hypot(relCx_center, relCy_center), PLAYER_SIZE);
            }
            
            // 3. Clear steps in cardinal directions (max 2 steps lookahead for state)
            const maxClearProbe = 2;
            const clearN = probeClearSteps(player, 0, -1, maxClearProbe);
            const clearS = probeClearSteps(player, 0, 1, maxClearProbe);
            const clearE = probeClearSteps(player, 1, 0, maxClearProbe);
            const clearW = probeClearSteps(player, -1, 0, maxClearProbe);

            // 4. Line of Sight to Coin and from Hunter
            const coinPathClear = (coins.length > 0) ? (isPathClear(player, coins[0], obstacles, player.width, player.height) ? 0 : 1) : 1; // 0=clear, 1=blocked
            const hunterPathClear = isPathClear(player, hunter, obstacles, player.width, player.height) ? 0 : 1; // 0=player visible, 1=player hidden
            
            return `${hunterAngle}_${hunterDist}_${coinAngle}_${coinDist}_${clearN}_${clearS}_${clearE}_${clearW}_${coinPathClear}_${hunterPathClear}`;
        }

        function chooseAction(state) {
            if (!qTable[state]) {
                qTable[state] = Array(ACTIONS.length).fill(0);
                qTableSizeEl.textContent = Object.keys(qTable).length;
            }
            if (Math.random() < epsilon) {
                return Math.floor(Math.random() * ACTIONS.length);
            } else {
                const qValues = qTable[state];
                const maxQ = Math.max(...qValues);
                const bestActions = qValues.reduce((acc, q, idx) => (q === maxQ ? acc.concat(idx) : acc), []);
                return bestActions[Math.floor(Math.random() * bestActions.length)];
            }
        }

        function updateQTable(prevState, action, reward, nextState) {
            if (!qTable[prevState]) qTable[prevState] = Array(ACTIONS.length).fill(0);
            if (!qTable[nextState]) {
                qTable[nextState] = Array(ACTIONS.length).fill(0);
                qTableSizeEl.textContent = Object.keys(qTable).length;
            }

            const oldQValue = qTable[prevState][action];
            const maxFutureQ = qTable[nextState].length > 0 ? Math.max(...qTable[nextState]) : 0;
            const newQValue = oldQValue + LEARNING_RATE * (reward + DISCOUNT_FACTOR * maxFutureQ - oldQValue);
            qTable[prevState][action] = newQValue;
        }
        
        function resetGame() {
            // Try to spawn player and hunter in clear, distant locations
            let attempts = 0;
            const maxSpawnAttempts = 20;
            do {
                player.x = PLAYER_SIZE + Math.random() * (gameCanvas.width - 3 * PLAYER_SIZE);
                player.y = PLAYER_SIZE + Math.random() * (gameCanvas.height - 3 * PLAYER_SIZE);
                attempts++;
            } while (obstacles.some(obs => rectCollision(player, obs)) && attempts < maxSpawnAttempts);
            
            attempts = 0;
            do {
                hunter.x = PLAYER_SIZE + Math.random() * (gameCanvas.width - 3 * PLAYER_SIZE);
                hunter.y = PLAYER_SIZE + Math.random() * (gameCanvas.height - 3 * PLAYER_SIZE);
                attempts++;
            } while ((obstacles.some(obs => rectCollision(hunter, obs)) || Math.hypot(player.x-hunter.x, player.y-hunter.y) < gameCanvas.width/3) && attempts < maxSpawnAttempts);


            spawnCoin();
            currentSteps = 0;
            episodeCount++;

            episodeEl.textContent = episodeCount;
            cookiesEl.textContent = scoreCookies;
            punishmentsEl.textContent = scorePunishments;
            if (epsilon > MIN_EPSILON) epsilon *= EPSILON_DECAY;
            epsilonEl.textContent = epsilon.toFixed(3);
            maxStepsInfoEl.textContent = MAX_STEPS_PER_EPISODE;
        }

        function moveEntity(entity, dxMultiplier, dyMultiplier) {
            const moveAmountX = dxMultiplier * MOVE_SPEED;
            const moveAmountY = dyMultiplier * MOVE_SPEED;

            const oldX = entity.x;
            const oldY = entity.y;
            let newX = entity.x + moveAmountX;
            let newY = entity.y + moveAmountY;

            // Canvas boundary collision for individual axes
            if (newX < 0) newX = 0;
            if (newX + entity.width > gameCanvas.width) newX = gameCanvas.width - entity.width;
            if (newY < 0) newY = 0;
            if (newY + entity.height > gameCanvas.height) newY = gameCanvas.height - entity.height;
            
            let finalX = oldX;
            let finalY = oldY;

            // Try moving X only
            let tempEntityX = { ...entity, x: newX, y: oldY };
            let collisionX = false;
            for (const obs of obstacles) {
                if (rectCollision(tempEntityX, obs)) {
                    collisionX = true;
                    break;
                }
            }
            if (!collisionX) finalX = newX;

            // Try moving Y only
            let tempEntityY = { ...entity, x: oldX, y: newY }; // Use oldX for this check
            let collisionY = false;
            for (const obs of obstacles) {
                if (rectCollision(tempEntityY, obs)) {
                    collisionY = true;
                    break;
                }
            }
            if (!collisionY) finalY = newY;

            // If trying to move diagonally and both individual X and Y moves were valid,
            // check the combined diagonal position.
            if (dxMultiplier !== 0 && dyMultiplier !== 0 && !collisionX && !collisionY) {
                let tempEntityXY = { ...entity, x: newX, y: newY };
                let collisionXY = false;
                for (const obs of obstacles) {
                    if (rectCollision(tempEntityXY, obs)) {
                        collisionXY = true;
                        break;
                    }
                }
                if (!collisionXY) { // Diagonal is clear
                    finalX = newX;
                    finalY = newY;
                } else { // Diagonal blocked, prefer to keep one of the valid axis movements
                         // This logic can be simple: if diagonal fails, it means only one axis should have moved.
                         // The current finalX, finalY already reflect single-axis valid moves.
                         // If player *wanted* to move diagonally, but couldn't, it effectively slides.
                }
            }
            
            entity.x = finalX;
            entity.y = finalY;
            return (finalX === oldX && finalY === oldY && (dxMultiplier !==0 || dyMultiplier !==0) ); // True if tried to move but couldn't
        }

        function updateGame(actionIndex) {
            const action = ACTIONS[actionIndex];
            lastActionEl.textContent = action.name;
            let reward = -0.05; // Slightly smaller penalty per step

            const playerStuck = moveEntity(player, action.dx, action.dy);
            if (playerStuck) {
                reward -= 0.5; // Penalize for bumping into walls if trying to move
            }

            // --- Hunter Movement (simple chase, obstacle aware) ---
            const hunterTargetX = player.x + player.width / 2;
            const hunterTargetY = player.y + player.height / 2;
            const hunterCurrentX = hunter.x + hunter.width / 2;
            const hunterCurrentY = hunter.y + hunter.height / 2;

            let hdx = 0, hdy = 0;
            if (Math.abs(hunterTargetX - hunterCurrentX) > MOVE_SPEED / 2) {
                hdx = Math.sign(hunterTargetX - hunterCurrentX);
            }
            if (Math.abs(hunterTargetY - hunterCurrentY) > MOVE_SPEED / 2) {
                hdy = Math.sign(hunterTargetY - hunterCurrentY);
            }
            moveEntity(hunter, hdx, hdy);


            if (rectCollision(player, hunter)) {
                reward -= 10;
                scorePunishments++;
                return { reward, done: true };
            }

            if (coins.length > 0) {
                const coin = coins[0];
                if (Math.hypot((player.x + player.width/2) - coin.x, (player.y + player.height/2) - coin.y) < player.width/2 + coin.radius) {
                    reward += 20;
                    scoreCookies++;
                    coins.splice(0, 1);
                    spawnCoin();
                    return { reward, done: true }; // End episode on coin collection
                }
            }
            
            currentSteps++;
            if (currentSteps >= MAX_STEPS_PER_EPISODE) {
                reward -= 5;
                scorePunishments++;
                return { reward, done: true };
            }
            return { reward, done: false };
        }

        function drawGame() {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            obstacles.forEach(obs => {
                gameCtx.fillStyle = obs.color;
                gameCtx.fillRect(obs.x, obs.y, obs.width, obs.height);
            });
            coins.forEach(coin => {
                gameCtx.beginPath();
                gameCtx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
                gameCtx.fillStyle = coin.color;
                gameCtx.fill();
            });
            gameCtx.fillStyle = player.color;
            gameCtx.fillRect(player.x, player.y, player.width, player.height);
            gameCtx.fillStyle = hunter.color;
            gameCtx.fillRect(hunter.x, hunter.y, hunter.width, hunter.height);
        }

        function drawAiVision() { // Simplified text-based vision
            aiVisionCtx.clearRect(0, 0, aiVisionCanvas.width, aiVisionCanvas.height);
            const stateStr = getDiscretizedState();
            const parts = stateStr.split('_');
            
            aiVisionCtx.fillStyle = '#ccc';
            aiVisionCtx.font = '11px monospace';
            let yPos = 15;
            const lineHeight = 13;

            if (parts.length === 10) {
                aiVisionCtx.fillText(`Hunter: ${parts[0]}A ${parts[1]}D`, 5, yPos); yPos += lineHeight;
                aiVisionCtx.fillText(`Coin:   ${parts[2]}A ${parts[3]}D`, 5, yPos); yPos += lineHeight;
                aiVisionCtx.fillText(`PathCoin: ${parts[8]==='0'?'CLR':'BLK'}`, 5, yPos); yPos += lineHeight;
                aiVisionCtx.fillText(`VisHunter:${parts[9]==='0'?'VIS':'HID'}`, 5, yPos); yPos += lineHeight;
                yPos += 5;
                aiVisionCtx.fillText(`Steps N:${parts[4]} S:${parts[5]}`, 5, yPos); yPos += lineHeight;
                aiVisionCtx.fillText(`Steps E:${parts[6]} W:${parts[7]}`, 5, yPos); yPos += lineHeight;
            } else {
                 aiVisionCtx.fillText(stateStr, 5, yPos, aiVisionCanvas.width - 10);
            }

            // Draw a mini-map representation for fun
            const mapScale = 0.25;
            const mapOffsetX = aiVisionCanvas.width / 2 - (gameCanvas.width * mapScale / 2) + 20;
            const mapOffsetY = yPos + 10;

            aiVisionCtx.save();
            aiVisionCtx.translate(mapOffsetX, mapOffsetY);
            aiVisionCtx.scale(mapScale, mapScale);

            //obstacles
            aiVisionCtx.fillStyle = '#888';
            obstacles.forEach(obs => aiVisionCtx.fillRect(obs.x, obs.y, obs.width, obs.height));
            //coin
            if (coins.length > 0) {
                aiVisionCtx.beginPath();
                aiVisionCtx.arc(coins[0].x, coins[0].y, coins[0].radius / mapScale * 0.5 , 0, Math.PI * 2); // Make coin visible
                aiVisionCtx.fillStyle = coins[0].color;
                aiVisionCtx.fill();
            }
            //hunter
            aiVisionCtx.fillStyle = hunter.color;
            aiVisionCtx.fillRect(hunter.x, hunter.y, hunter.width, hunter.height);
            //player
            aiVisionCtx.fillStyle = player.color;
            aiVisionCtx.fillRect(player.x, player.y, player.width, player.height);
            
            aiVisionCtx.restore();
        }


        function aiLoop() {
            const currentState = getDiscretizedState();
            const actionToTake = chooseAction(currentState);
            const gameOutcome = updateGame(actionToTake);
            const nextStateAfterAction = getDiscretizedState();
            updateQTable(currentState, actionToTake, gameOutcome.reward, nextStateAfterAction);
            drawGame();
            drawAiVision();
            if (gameOutcome.done) {
                resetGame();
            }
        }

        function init() {
            currentSimSpeed = parseInt(speedControl.value);
            speedValue.textContent = currentSimSpeed;
            
            speedControl.addEventListener('input', (e) => {
                currentSimSpeed = parseInt(e.target.value);
                speedValue.textContent = currentSimSpeed;
                if (simIntervalId) clearInterval(simIntervalId);
                simIntervalId = setInterval(aiLoop, currentSimSpeed);
            });
            
            resetGame(); // Initial reset
            drawGame();
            drawAiVision();
            if (simIntervalId) clearInterval(simIntervalId); // Clear if any previous
            simIntervalId = setInterval(aiLoop, currentSimSpeed);
        }

        window.onload = init;
    </script>
</body>
</html>
