<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MP3 Lyrics Visualizer (9:16)</title>
    <!-- jsmediatags library for reading MP3 metadata -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>

    <style>
        :root {
            --bg-color: #111;
            --text-color: #eee;
            --accent-color: #00ffff;
            --highlight-color: #ff00ff;
            --font-family: 'Arial', sans-serif;
            --animation-duration: 0.8s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars on the body */
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .visualizer-container {
            width: 100vw;
            height: 100vh;
            /* Enforce 9:16 aspect ratio if you embed this elsewhere. 
               For full screen mobile, 100vw/vh works.
               Example for fixed size: width: 360px; height: 640px; */
            background: linear-gradient(45deg, #1a001a, #001a1a, #1a1a00);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Pushes controls down */
            padding: 20px;
            overflow: hidden; /* Important for containing animated elements */
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .info-area {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            opacity: 0.8;
        }

        #file-input-label {
            display: inline-block;
            padding: 12px 25px;
            background-color: var(--accent-color);
            color: var(--bg-color);
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s ease, background-color 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        #file-input-label:hover {
            transform: scale(1.05);
            background-color: var(--highlight-color);
            box-shadow: 0 6px 20px rgba(255, 0, 255, 0.4);
        }

        #mp3File {
            display: none; /* Hide the default input */
        }

        #lyrics-display-area {
            width: 90%;
            height: 60%; /* Adjust as needed */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center lines */
            align-items: center; /* Horizontally center lines */
            overflow: hidden; /* Crucial: hides lines not yet visible */
            position: relative; /* For absolute positioning of lines */
            text-align: center;
            margin-bottom: 20px;
        }

        .lyric-line {
            font-size: clamp(1.5rem, 5vw, 2.5rem); /* Responsive font size */
            line-height: 1.4;
            margin-bottom: 15px;
            opacity: 0;
            transform: translateY(30px) scale(0.9);
            transition: opacity var(--animation-duration) ease-out, 
                        transform var(--animation-duration) ease-out,
                        color 0.3s ease;
            color: var(--text-color);
            font-weight: normal;
            text-shadow: 0 0 5px rgba(255,255,255,0.3);
        }

        .lyric-line.visible {
            opacity: 0.7; /* Non-active visible lines */
            transform: translateY(0) scale(1);
        }

        .lyric-line.active {
            opacity: 1;
            transform: translateY(0) scale(1.1); /* Slightly larger active line */
            color: var(--accent-color);
            font-weight: bold;
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--accent-color);
        }
        
        .lyric-line.past {
            opacity: 0.3;
            transform: translateY(-30px) scale(0.9);
        }

        #audio-controls {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
            position: absolute;
            bottom: 20px; /* Position at the bottom */
        }

        #audioPlayer {
            width: 80%;
            max-width: 400px;
            opacity: 0.8;
            border-radius: 25px;
        }
         #audioPlayer:focus {
            outline: none;
         }

        /* Custom styled controls (optional, adds complexity) */
        /* Hide default controls if implementing custom */
        /* audio::-webkit-media-controls-panel { display: none !important; }
        audio::-webkit-media-controls-play-button { display: none !important; }
        audio::-webkit-media-controls-timeline { display: none !important; }
        audio::-webkit-media-controls-current-time-display { display: none !important; }
        audio::-webkit-media-controls-time-remaining-display { display: none !important; }
        audio::-webkit-media-controls-mute-button { display: none !important; }
        audio::-webkit-media-controls-volume-slider { display: none !important; } */

        #status-message {
            margin-top: 15px;
            font-style: italic;
            color: var(--accent-color);
            min-height: 1.2em; /* Reserve space */
        }

    </style>
</head>
<body>
    <div class="visualizer-container">
        <div class="info-area">
            <h1>Lyrics Visualizer</h1>
            <p>Upload an MP3 with embedded lyrics</p>
        </div>

        <label for="mp3File" id="file-input-label">Select MP3 File</label>
        <input type="file" id="mp3File" accept=".mp3">
        
        <div id="status-message">Drop your MP3 here or click above!</div>

        <div id="lyrics-display-area">
            <!-- Lyric lines will be injected here -->
        </div>

        <div id="audio-controls">
            <audio id="audioPlayer" controls></audio>
        </div>
    </div>

    <script>
        const mp3FileInput = document.getElementById('mp3File');
        const audioPlayer = document.getElementById('audioPlayer');
        const lyricsDisplayArea = document.getElementById('lyrics-display-area');
        const statusMessage = document.getElementById('status-message');
        const fileInputLabel = document.getElementById('file-input-label');

        let parsedLyrics = []; // Array of {time, text} objects
        let currentLyricIndex = -1;
        let animationFrameId;

        // Make the whole container a drop zone
        const visualizerContainer = document.querySelector('.visualizer-container');
        visualizerContainer.addEventListener('dragover', (event) => {
            event.preventDefault();
            event.stopPropagation();
            visualizerContainer.style.border = '2px dashed var(--accent-color)';
        });
        visualizerContainer.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
            visualizerContainer.style.border = 'none';
        });
        visualizerContainer.addEventListener('drop', (event) => {
            event.preventDefault();
            event.stopPropagation();
            visualizerContainer.style.border = 'none';
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        mp3FileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        function handleFile(file) {
            if (file.type !== "audio/mpeg") {
                statusMessage.textContent = "Please select an MP3 file.";
                return;
            }
            statusMessage.textContent = "Processing MP3...";
            fileInputLabel.textContent = "Loading...";

            const objectURL = URL.createObjectURL(file);
            audioPlayer.src = objectURL;
            audioPlayer.pause(); // Pause until lyrics are ready

            parsedLyrics = [];
            lyricsDisplayArea.innerHTML = ''; // Clear previous lyrics
            currentLyricIndex = -1;

            window.jsmediatags.read(file, {
                onSuccess: function(tag) {
                    console.log(tag);
                    let lyricsText = null;
                    if (tag.tags.lyrics) {
                        // .lyrics can be a string or an object {language, description, text}
                        lyricsText = typeof tag.tags.lyrics === 'string' ? tag.tags.lyrics : tag.tags.lyrics.lyrics;
                    } else if (tag.tags.USLT) { // Check for USLT frame directly if lyrics is not populated
                         lyricsText = typeof tag.tags.USLT === 'string' ? tag.tags.USLT : tag.tags.USLT.lyrics;
                    }


                    if (lyricsText) {
                        statusMessage.textContent = "Lyrics found! Parsing...";
                        parseLyrics(lyricsText);
                        if (parsedLyrics.length > 0) {
                            statusMessage.textContent = "Lyrics ready!";
                            audioPlayer.play();
                        } else {
                            statusMessage.textContent = "Lyrics found, but format is not LRC. Displaying as plain text.";
                            displayPlainTextLyrics(lyricsText); // Fallback for non-LRC
                            audioPlayer.play();
                        }
                    } else {
                        statusMessage.textContent = "No embedded lyrics found in this MP3.";
                        lyricsDisplayArea.innerHTML = `<div class="lyric-line visible" style="opacity:1;">No embedded lyrics.</div>`;
                    }
                    fileInputLabel.textContent = "Select New MP3";
                },
                onError: function(error) {
                    console.error('Error reading MP3 tags:', error);
                    statusMessage.textContent = "Error reading MP3 file.";
                    lyricsDisplayArea.innerHTML = `<div class="lyric-line visible" style="opacity:1;">Could not read MP3.</div>`;
                    fileInputLabel.textContent = "Select MP3 File";
                }
            });
        }

        function parseLyrics(lyricsText) {
            parsedLyrics = [];
            const lines = lyricsText.split('\n');
            const lrcRegex = /\[(\d{2}):(\d{2})\.?(\d{2,3})?\](.*)/;

            let hasTimestamps = false;

            for (const line of lines) {
                const match = lrcRegex.exec(line);
                if (match) {
                    hasTimestamps = true;
                    const minutes = parseInt(match[1]);
                    const seconds = parseInt(match[2]);
                    const milliseconds = match[3] ? parseInt(match[3].padEnd(3, '0')) : 0; // Pad to 3 digits for ms if 2 are given
                    const time = minutes * 60 + seconds + milliseconds / 1000;
                    const text = match[4].trim();
                    if (text) { // Only add if there's actual lyric text
                        parsedLyrics.push({ time, text });
                    }
                } else if (line.trim() && !hasTimestamps) { 
                    // If we encounter non-timestamped lines and haven't found any timestamps yet,
                    // treat as plain text. This is a simple heuristic.
                    // A more robust parser might handle mixed content or allow only LRC.
                    parsedLyrics.push({ time: null, text: line.trim() });
                }
            }

            if (hasTimestamps) {
                // Sort by time if we successfully parsed LRC
                parsedLyrics.sort((a, b) => a.time - b.time);
            } else {
                // If no timestamps found after parsing all lines, clear and treat as plain text
                parsedLyrics = []; 
            }
        }
        
        function displayPlainTextLyrics(lyricsText) {
            lyricsDisplayArea.innerHTML = ''; // Clear previous
            const lines = lyricsText.split('\n').filter(line => line.trim() !== '');
            
            // Simple display for plain text: Show a few lines at a time
            // This won't sync, but will show the lyrics.
            let lineBatch = [];
            const maxLinesToShow = 3; // Number of lines to show at once for plain text

            lines.forEach((text, index) => {
                lineBatch.push(text);
                if (lineBatch.length === maxLinesToShow || index === lines.length - 1) {
                    const lineDiv = document.createElement('div');
                    lineDiv.classList.add('lyric-line');
                    lineDiv.innerHTML = lineBatch.join('<br>'); // Join lines with <br>
                    lyricsDisplayArea.appendChild(lineDiv);
                    
                    // Trigger animation with a slight delay for staggering
                    setTimeout(() => {
                        lineDiv.classList.add('visible');
                        // If it's the first batch, also mark as 'active' for initial highlight
                        if (lyricsDisplayArea.children.length === 1) {
                            lineDiv.classList.add('active');
                        }
                    }, index * 100); // Stagger appearance slightly
                    lineBatch = []; // Reset batch
                }
            });
             if (lyricsDisplayArea.children.length === 0) {
                 lyricsDisplayArea.innerHTML = `<div class="lyric-line visible active">Lyrics loaded, but no specific timing.</div>`;
             }
        }


        function updateLyricsDisplay() {
            if (!parsedLyrics.length || parsedLyrics[0].time === null) {
                // If lyrics are plain text (no timestamps), this function won't be called by timeupdate
                // or it will do nothing if accidentally called.
                // Plain text is handled by displayPlainTextLyrics.
                return;
            }

            const currentTime = audioPlayer.currentTime;
            let newLyricIndex = -1;

            // Find the current lyric line
            for (let i = 0; i < parsedLyrics.length; i++) {
                if (currentTime >= parsedLyrics[i].time) {
                    newLyricIndex = i;
                } else {
                    break; 
                }
            }

            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                renderLyrics();
            }
            animationFrameId = requestAnimationFrame(updateLyricsDisplay);
        }
        
        function renderLyrics() {
            lyricsDisplayArea.innerHTML = ''; // Clear previous lines

            // Determine the range of lyrics to display (e.g., 1 past, 1 current, 2 future)
            const displayWindow = {
                past: 1,
                future: 2,
            };

            let linesToRender = [];

            // Add past lines
            for (let i = 1; i <= displayWindow.past; i++) {
                if (currentLyricIndex - i >= 0) {
                    linesToRender.unshift({ ...parsedLyrics[currentLyricIndex - i], type: 'past' });
                }
            }

            // Add current line
            if (currentLyricIndex >= 0 && currentLyricIndex < parsedLyrics.length) {
                linesToRender.push({ ...parsedLyrics[currentLyricIndex], type: 'active' });
            } else if (parsedLyrics.length > 0 && currentLyricIndex < 0) {
                 // Before first lyric, show the first one as upcoming/visible but not active
                 linesToRender.push({ ...parsedLyrics[0], type: 'visible' });
            }


            // Add future lines
            for (let i = 1; i <= displayWindow.future; i++) {
                if (currentLyricIndex + i < parsedLyrics.length) {
                    linesToRender.push({ ...parsedLyrics[currentLyricIndex + i], type: 'visible' });
                }
            }
            
            // If very few lyrics (e.g., only one), ensure it's shown
            if (linesToRender.length === 0 && parsedLyrics.length > 0) {
                 const type = currentLyricIndex === 0 && audioPlayer.currentTime >= parsedLyrics[0].time ? 'active' : 'visible';
                 linesToRender.push({ ...parsedLyrics[0], type: type });
            }


            linesToRender.forEach(lyricData => {
                const lineDiv = document.createElement('div');
                lineDiv.classList.add('lyric-line');
                lineDiv.textContent = lyricData.text;
                lyricsDisplayArea.appendChild(lineDiv);

                // Stagger animation slightly based on type for effect
                let delay = 0;
                if (lyricData.type === 'active') delay = 50;
                else if (lyricData.type === 'visible') delay = 100;
                
                setTimeout(() => {
                    lineDiv.classList.add(lyricData.type);
                }, delay);
            });
        }

        audioPlayer.addEventListener('play', () => {
            if (parsedLyrics.length > 0 && parsedLyrics[0].time !== null) { // Only if LRC
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(updateLyricsDisplay);
                // Initial render on play if needed
                if (currentLyricIndex === -1) renderLyrics(); 
            }
        });

        audioPlayer.addEventListener('pause', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        });
        
        audioPlayer.addEventListener('ended', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            // Optionally show all lyrics or a "song ended" message
            if (parsedLyrics.length > 0 && parsedLyrics[0].time !== null) {
                currentLyricIndex = parsedLyrics.length -1; // Mark last as active visually
                renderLyrics(); // Show final state
            }
        });

        audioPlayer.addEventListener('seeked', () => {
            // When user seeks, immediately update lyrics
            if (parsedLyrics.length > 0 && parsedLyrics[0].time !== null) {
                 currentLyricIndex = -1; // Force re-evaluation
                 updateLyricsDisplay(); // Call once to resync
            }
        });

        // Initial welcome message display
        lyricsDisplayArea.innerHTML = `<div class="lyric-line visible active" style="opacity:1;">Welcome! Load an MP3 to start.</div>`;

    </script>
</body>
</html>
