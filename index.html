<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Hide & Collect - Dyna-Q</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            padding: 5px;
            overscroll-behavior: none;
        }
        .controls {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 5px;
            background-color: #2a2a2a;
            border-radius: 5px;
            width: calc(100% - 10px);
            max-width: 780px;
            box-sizing: border-box;
        }
        .controls div { display: flex; flex-direction: column; align-items: center; }
        .controls label { font-size: 0.8em; margin-bottom: 2px; }
        .controls input[type="range"] { width: 100px; }
        .controls span { font-size: 0.8em; }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 400px;
        }
        canvas {
            border: 1px solid #444;
            background-color: #282828;
            max-width: 100%;
            height: auto;
            display: block;
        }
        #gameCanvas { background-color: #304050; }
        #aiVisionCanvas { background-color: #333; }
        .stats {
            border: 1px solid #444;
            padding: 8px;
            background-color: #2f2f2f;
            width: calc(100% - 18px);
            max-width: 380px;
            box-sizing: border-box;
        }
        .stats p { margin: 4px 0; font-size: 0.8em; }
        h1, h2 { text-align: center; margin-top: 5px; margin-bottom: 8px; }
        h1 {font-size: 1.5em;}
        h2 { font-size: 1.0em; }

        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                align-items: flex-start;
                max-width: 800px; /* Increased max-width */
            }
            .game-area { flex: 2; }
            .ai-info { flex: 1; }
            .stats { width: auto; max-width: none; }
            .controls input[type="range"] { width: 120px; }
        }
    </style>
</head>
<body>
    <h1>AI Hide & Collect (Dyna-Q)</h1>

    <div class="controls">
        <div>
            <label for="speedControl">Sim Speed (ms):</label>
            <input type="range" id="speedControl" min="10" max="500" value="50">
            <span id="speedValue">50</span>
        </div>
        <div>
            <label for="planningStepsControl">Planning Steps (k):</label>
            <input type="range" id="planningStepsControl" min="0" max="50" value="10">
            <span id="planningStepsValue">10</span>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
            <h2>Game World</h2>
            <canvas id="gameCanvas" width="300" height="450"></canvas>
        </div>
        <div class="ai-info">
            <h2>AI "Vision" & Model</h2>
            <canvas id="aiVisionCanvas" width="150" height="150"></canvas> <!-- Smaller for stats -->
            <div class="stats">
                <h2>Stats</h2>
                <p>Episode: <span id="episode">0</span></p>
                <p>Cookies: <span id="cookies">0</span></p>
                <p>Punishments: <span id="punishments">0</span></p>
                <p>Epsilon: <span id="epsilon">1.000</span></p>
                <p>Last Action: <span id="lastAction">-</span></p>
                <p>Q-Table Size: <span id="qTableSize">0</span></p>
                <p>Env. Model Size: <span id="modelSize">0</span></p>
                <p>Total Steps: <span id="totalSteps">0</span></p>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const aiVisionCanvas = document.getElementById('aiVisionCanvas');
        const aiVisionCtx = aiVisionCanvas.getContext('2d');

        const episodeEl = document.getElementById('episode');
        const cookiesEl = document.getElementById('cookies');
        const punishmentsEl = document.getElementById('punishments');
        const epsilonEl = document.getElementById('epsilon');
        const lastActionEl = document.getElementById('lastAction');
        const qTableSizeEl = document.getElementById('qTableSize');
        const modelSizeEl = document.getElementById('modelSize');
        const totalStepsEl = document.getElementById('totalSteps');

        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const planningStepsControl = document.getElementById('planningStepsControl');
        const planningStepsValue = document.getElementById('planningStepsValue');

        // --- Game Constants ---
        const PLAYER_SIZE = 15;
        const HUNTER_SIZE = 15;
        const COIN_RADIUS = 7;
        const MOVE_SPEED = PLAYER_SIZE;
        let MAX_STEPS_PER_EPISODE = 350; // Reduced slightly due to planning overhead

        // --- Game Objects & State ---
        let player = { x: 50, y: 50, width: PLAYER_SIZE, height: PLAYER_SIZE, color: 'blue' };
        let hunter = { x: gameCanvas.width - 50, y: gameCanvas.height - 50, width: HUNTER_SIZE, height: HUNTER_SIZE, color: 'red' };
        let coins = [];
        let obstacles = [
            { x: 100, y: 0, width: 20, height: 120, color: '#555' },
            { x: 100, y: gameCanvas.height - 120, width: 20, height: 120, color: '#555' },
            { x: 180, y: 200, width: 100, height: 20, color: '#555' },
            { x: 0, y: gameCanvas.height/2 - 10, width: 70, height: 20, color: '#555' },
            { x: gameCanvas.width-70, y: gameCanvas.height/2 - 50, width: 70, height: 20, color: '#555' },
            { x: 50, y: 50, width: 20, height: 80, color: '#555' },
            { x: gameCanvas.width - 70, y: gameCanvas.height - 130, width: 20, height: 80, color: '#555' }
        ];

        // --- AI Q-Learning & Dyna-Q Parameters ---
        let qTable = {};
        let envModel = {}; // Stores { state: { action: { next_state_counts: {s': count}, total_reward: sum, experience_count: n }}}
        let observedStateActions = []; // For sampling during planning

        const LEARNING_RATE = 0.1;
        const DISCOUNT_FACTOR = 0.9;
        let epsilon = 1.0;
        const EPSILON_DECAY = 0.9998; // Slightly faster decay as learning should be more efficient
        const MIN_EPSILON = 0.05;     // Lower min epsilon
        let numPlanningSteps = 10;    // k for Dyna-Q

        const ACTIONS = [
            { dx: 0, dy: -1, name: "Up" },
            { dx: 0, dy: 1, name: "Down" },
            { dx: -1, dy: 0, name: "Left" },
            { dx: 1, dy: 0, name: "Right" },
            { dx: 0, dy: 0, name: "Stay" }
        ];

        let scoreCookies = 0;
        let scorePunishments = 0;
        let episodeCount = 0;
        let currentStepsInEpisode = 0;
        let cumulativeTotalSteps = 0;

        let simIntervalId = null;
        let currentSimSpeed = 50;

        // --- Helper Functions (Collision, Spawning - mostly unchanged) ---
        function rectCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function spawnCoin() { /* ... (same as previous version) ... */
            let coinX, coinY, validPosition;
            const maxAttempts = 50;
            let attempts = 0;
            do {
                validPosition = true;
                attempts++;
                coinX = COIN_RADIUS + Math.random() * (gameCanvas.width - 2 * COIN_RADIUS);
                coinY = COIN_RADIUS + Math.random() * (gameCanvas.height - 2 * COIN_RADIUS);
                const tempCoinCircle = { x: coinX, y: coinY, radius: COIN_RADIUS };

                for (const obs of obstacles) { 
                    const obsCenterX = obs.x + obs.width / 2;
                    const obsCenterY = obs.y + obs.height / 2;
                    const distToObsCenter = Math.hypot(coinX - obsCenterX, coinY - obsCenterY);
                    if (distToObsCenter < COIN_RADIUS + Math.max(obs.width, obs.height) / 2) {
                        if (coinX > obs.x && coinX < obs.x + obs.width && coinY > obs.y && coinY < obs.y + obs.height) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                if (!validPosition) continue;
                if (Math.hypot(coinX - (player.x+player.width/2), coinY - (player.y+player.height/2)) < PLAYER_SIZE * 3 + COIN_RADIUS) validPosition = false; // increased distance
                if (Math.hypot(coinX - (hunter.x+hunter.width/2), coinY - (hunter.y+hunter.height/2)) < HUNTER_SIZE * 3 + COIN_RADIUS) validPosition = false; // increased distance

            } while (!validPosition && attempts < maxAttempts);

            if (!validPosition) { 
                coinX = gameCanvas.width * Math.random(); // More random fallback
                coinY = gameCanvas.height * Math.random();
            }
            coins = [{ x: coinX, y: coinY, radius: COIN_RADIUS, color: 'lime' }];
        }


        // --- State Discretization (same as "Bigger Brain") ---
        function getAngleCategory(dx, dy) { /* ... */ return Math.floor((Math.atan2(dy, dx) + Math.PI) / (Math.PI / 4)) % 8; }
        function getDistanceCategory(dist, entitySize) { /* ... */ 
            if (dist < entitySize * 2) return 0; 
            if (dist < entitySize * 5) return 1; 
            if (dist < entitySize * 10) return 2; 
            return 3;
        }
        function probeClearSteps(entity, unitDirX, unitDirY, maxProbeSteps) { /* ... */ 
            let clearSteps = 0;
            for (let i = 1; i <= maxProbeSteps; i++) {
                const nextX = entity.x + unitDirX * i * MOVE_SPEED;
                const nextY = entity.y + unitDirY * i * MOVE_SPEED;
                const probeRect = { x: nextX, y: nextY, width: entity.width, height: entity.height };

                if (probeRect.x < 0 || probeRect.x + probeRect.width > gameCanvas.width ||
                    probeRect.y < 0 || probeRect.y + probeRect.height > gameCanvas.height) break;
                
                if (obstacles.some(obs => rectCollision(probeRect, obs))) break;
                clearSteps++;
            }
            if (clearSteps === 0) return 0;
            if (clearSteps === 1) return 1;
            return 2;
        }
        function isPathClear(entity1, entity2, obstaclesArr, checkWidth, checkHeight) { /* ... */
            const e1cx = entity1.x + entity1.width / 2;
            const e1cy = entity1.y + entity1.height / 2;
            const e2Obj = (entity2.radius) ? { x: entity2.x, y: entity2.y, width: entity2.radius*2, height: entity2.radius*2 } : entity2; // Handle coin
            const e2cx = e2Obj.x + e2Obj.width / 2;
            const e2cy = e2Obj.y + e2Obj.height / 2;

            const dx = e2cx - e1cx;
            const dy = e2cy - e1cy;
            const dist = Math.hypot(dx, dy);

            if (dist < PLAYER_SIZE/4) return true; 
            const numSamples = Math.max(2, Math.ceil(dist / (PLAYER_SIZE / 3)));

            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const currentX = e1cx + t * dx;
                const currentY = e1cy + t * dy;
                const probeRect = { x: currentX - checkWidth / 2, y: currentY - checkHeight / 2, width: checkWidth, height: checkHeight };
                if (obstaclesArr.some(obs => rectCollision(probeRect, obs))) return false;
            }
            return true;
        }
        function getDiscretizedState() { /* ... (same as "Bigger Brain") ... */
            const relHx_center = (hunter.x + hunter.width/2) - (player.x + player.width/2);
            const relHy_center = (hunter.y + hunter.height/2) - (player.y + player.height/2);
            const hunterAngle = getAngleCategory(relHx_center, relHy_center);
            const hunterDist = getDistanceCategory(Math.hypot(relHx_center, relHy_center), PLAYER_SIZE);

            let coinAngle = 0, coinDist = 3; 
            if (coins.length > 0) {
                const coin = coins[0];
                const relCx_center = coin.x - (player.x + player.width/2);
                const relCy_center = coin.y - (player.y + player.height/2);
                coinAngle = getAngleCategory(relCx_center, relCy_center);
                coinDist = getDistanceCategory(Math.hypot(relCx_center, relCy_center), PLAYER_SIZE);
            }
            
            const maxClearProbe = 2;
            const clearN = probeClearSteps(player, 0, -1, maxClearProbe);
            const clearS = probeClearSteps(player, 0, 1, maxClearProbe);
            const clearE = probeClearSteps(player, 1, 0, maxClearProbe);
            const clearW = probeClearSteps(player, -1, 0, maxClearProbe);

            const coinPathClear = (coins.length > 0) ? (isPathClear(player, coins[0], obstacles, player.width, player.height) ? 0 : 1) : 1;
            const hunterPathClear = isPathClear(hunter, player, obstacles, hunter.width, hunter.height) ? 0 : 1; // Hunter's LoS to player
            
            return `${hunterAngle}_${hunterDist}_${coinAngle}_${coinDist}_${clearN}_${clearS}_${clearE}_${clearW}_${coinPathClear}_${hunterPathClear}`;
        }

        // --- Q-Learning & Model Functions ---
        function ensureQValue(state, actionIndex = -1) {
            if (!qTable[state]) {
                qTable[state] = Array(ACTIONS.length).fill(0);
                qTableSizeEl.textContent = Object.keys(qTable).length;
            }
            if (actionIndex !== -1 && qTable[state][actionIndex] === undefined) {
                 qTable[state][actionIndex] = 0; // Should not happen if array is filled
            }
        }

        function chooseAction(state) {
            ensureQValue(state);
            if (Math.random() < epsilon) {
                return Math.floor(Math.random() * ACTIONS.length);
            } else {
                const qValues = qTable[state];
                const maxQ = Math.max(...qValues);
                const bestActions = qValues.reduce((acc, q, idx) => (q === maxQ ? acc.concat(idx) : acc), []);
                return bestActions[Math.floor(Math.random() * bestActions.length)];
            }
        }

        function updateQTable(state, action, reward, nextState, isTerminal = false) {
            ensureQValue(state, action);
            ensureQValue(nextState); // Ensure nextState Q-values exist, even if it's new

            const oldQValue = qTable[state][action];
            let maxFutureQ = 0;
            if (!isTerminal) { // For terminal states, future Q is 0
                 maxFutureQ = qTable[nextState] && qTable[nextState].length > 0 ? Math.max(...qTable[nextState]) : 0;
            }
           
            const newQValue = oldQValue + LEARNING_RATE * (reward + DISCOUNT_FACTOR * maxFutureQ - oldQValue);
            qTable[state][action] = newQValue;
        }

        function updateModel(state, action, reward, nextState) {
            if (!envModel[state]) {
                envModel[state] = {};
                modelSizeEl.textContent = Object.keys(envModel).length; // Update based on first-level keys
            }
            if (!envModel[state][action]) {
                envModel[state][action] = {
                    next_state_counts: {},
                    total_reward: 0,
                    experience_count: 0
                };
                // Add to list of observed (s,a) pairs for planning
                observedStateActions.push({s: state, a: action});
            }
            const modelEntry = envModel[state][action];
            modelEntry.total_reward += reward;
            modelEntry.experience_count++;
            modelEntry.next_state_counts[nextState] = (modelEntry.next_state_counts[nextState] || 0) + 1;
        }

        function planningStep() {
            if (observedStateActions.length === 0) return;

            // Randomly sample a previously observed state-action pair
            const randomIndex = Math.floor(Math.random() * observedStateActions.length);
            const { s: s_m, a: a_m } = observedStateActions[randomIndex];

            const modelEntry = envModel[s_m]?.[a_m];
            if (!modelEntry || modelEntry.experience_count === 0) return; // Should not happen if s_m, a_m from observed list

            // Predict reward
            const r_m = modelEntry.total_reward / modelEntry.experience_count;

            // Predict next state (simplistic: choose most frequent)
            let s_prime_m = null;
            let maxCount = 0;
            for (const [next_s, count] of Object.entries(modelEntry.next_state_counts)) {
                if (count > maxCount) {
                    maxCount = count;
                    s_prime_m = next_s;
                }
            }
            if (s_prime_m === null) return; // No next state learned for this (s,a) yet

            // Perform Q-update with simulated experience
            // For planning, we need to know if s_prime_m is terminal.
            // This is tricky without full game logic access here.
            // A common simplification in Dyna-Q is to assume non-terminal for planning updates unless model specifically stores terminal flags.
            // Or, one can check if s_prime_m leads to a known terminal condition based on game rules, if state is parsable.
            // For now, we'll assume non-terminal for planning updates for simplicity, but this is a known simplification.
            updateQTable(s_m, a_m, r_m, s_prime_m, false); // Assuming s_prime_m is not terminal for planning update
        }

        // --- Game Logic (Reset, Movement, Update - mostly same, with minor tweaks) ---
        function resetGame() { /* ... (same as previous, player/hunter spawn, coin spawn) ... */
            let attempts = 0;
            const maxSpawnAttempts = 30;
            do {
                player.x = PLAYER_SIZE + Math.random() * (gameCanvas.width - 3 * PLAYER_SIZE);
                player.y = PLAYER_SIZE + Math.random() * (gameCanvas.height - 3 * PLAYER_SIZE);
                attempts++;
            } while (obstacles.some(obs => rectCollision(player, obs)) && attempts < maxSpawnAttempts);
            
            attempts = 0;
            do {
                hunter.x = PLAYER_SIZE + Math.random() * (gameCanvas.width - 3 * PLAYER_SIZE);
                hunter.y = PLAYER_SIZE + Math.random() * (gameCanvas.height - 3 * PLAYER_SIZE);
                attempts++;
            } while ((obstacles.some(obs => rectCollision(hunter, obs)) || Math.hypot(player.x-hunter.x, player.y-hunter.y) < gameCanvas.width/2.5) && attempts < maxSpawnAttempts);

            spawnCoin();
            currentStepsInEpisode = 0;
            episodeCount++;

            episodeEl.textContent = episodeCount;
            cookiesEl.textContent = scoreCookies;
            punishmentsEl.textContent = scorePunishments;
            if (epsilon > MIN_EPSILON) epsilon *= EPSILON_DECAY;
            epsilonEl.textContent = epsilon.toFixed(3);
        }
        function moveEntity(entity, dxMultiplier, dyMultiplier) { /* ... (same as previous) ... */
            const moveAmountX = dxMultiplier * MOVE_SPEED;
            const moveAmountY = dyMultiplier * MOVE_SPEED;

            const oldX = entity.x;
            const oldY = entity.y;
            let newX = entity.x + moveAmountX;
            let newY = entity.y + moveAmountY;

            if (newX < 0) newX = 0;
            if (newX + entity.width > gameCanvas.width) newX = gameCanvas.width - entity.width;
            if (newY < 0) newY = 0;
            if (newY + entity.height > gameCanvas.height) newY = gameCanvas.height - entity.height;
            
            let finalX = oldX;
            let finalY = oldY;

            let tempEntityX = { ...entity, x: newX, y: oldY };
            let collisionX = obstacles.some(obs => rectCollision(tempEntityX, obs));
            if (!collisionX) finalX = newX;

            let tempEntityY = { ...entity, x: oldX, y: newY }; 
            let collisionY = obstacles.some(obs => rectCollision(tempEntityY, obs));
            if (!collisionY) finalY = newY;
            
            if (dxMultiplier !== 0 && dyMultiplier !== 0 && !collisionX && !collisionY) {
                let tempEntityXY = { ...entity, x: newX, y: newY };
                if (!obstacles.some(obs => rectCollision(tempEntityXY, obs))) {
                    finalX = newX;
                    finalY = newY;
                }
            }
            
            entity.x = finalX;
            entity.y = finalY;
            return (finalX === oldX && finalY === oldY && (dxMultiplier !==0 || dyMultiplier !==0) );
        }
        function updateGame(actionIndex) { /* ... (mostly same, returns {reward, done}) ... */
            const action = ACTIONS[actionIndex];
            lastActionEl.textContent = action.name;
            let reward = -0.02; // Even smaller penalty for existing

            const playerStuck = moveEntity(player, action.dx, action.dy);
            if (playerStuck) reward -= 0.2;

            const hunterTargetX = player.x + player.width / 2;
            const hunterTargetY = player.y + player.height / 2;
            const hunterCurrentX = hunter.x + hunter.width / 2;
            const hunterCurrentY = hunter.y + hunter.height / 2;

            let hdx = 0, hdy = 0;
            if (Math.abs(hunterTargetX - hunterCurrentX) > MOVE_SPEED / 3) { // Hunter more sensitive
                hdx = Math.sign(hunterTargetX - hunterCurrentX);
            }
            if (Math.abs(hunterTargetY - hunterCurrentY) > MOVE_SPEED / 3) {
                hdy = Math.sign(hunterTargetY - hunterCurrentY);
            }
            moveEntity(hunter, hdx, hdy);

            if (rectCollision(player, hunter)) {
                reward -= 20; // Stronger punishment
                scorePunishments++;
                return { reward, done: true };
            }

            if (coins.length > 0) {
                const coin = coins[0];
                if (Math.hypot((player.x + player.width/2) - coin.x, (player.y + player.height/2) - coin.y) < player.width/2 + coin.radius) {
                    reward += 20;
                    scoreCookies++;
                    coins.splice(0, 1);
                    spawnCoin();
                    return { reward, done: true };
                }
            }
            
            currentStepsInEpisode++;
            cumulativeTotalSteps++;
            totalStepsEl.textContent = cumulativeTotalSteps;

            if (currentStepsInEpisode >= MAX_STEPS_PER_EPISODE) {
                reward -= 10; // Stronger timeout punishment
                scorePunishments++;
                return { reward, done: true };
            }
            return { reward, done: false };
        }

        // --- Drawing Functions ---
        function drawGame() { /* ... (same as previous) ... */
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            obstacles.forEach(obs => { gameCtx.fillStyle = obs.color; gameCtx.fillRect(obs.x, obs.y, obs.width, obs.height); });
            coins.forEach(coin => { gameCtx.beginPath(); gameCtx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2); gameCtx.fillStyle = coin.color; gameCtx.fill(); });
            gameCtx.fillStyle = player.color; gameCtx.fillRect(player.x, player.y, player.width, player.height);
            gameCtx.fillStyle = hunter.color; gameCtx.fillRect(hunter.x, hunter.y, hunter.width, hunter.height);
        }
        function drawAiVision() { /* ... (same text/minimap as previous) ... */
            aiVisionCtx.clearRect(0, 0, aiVisionCanvas.width, aiVisionCanvas.height);
            const stateStr = getDiscretizedState();
            const parts = stateStr.split('_');
            
            aiVisionCtx.fillStyle = '#ddd'; // Brighter text
            aiVisionCtx.font = '10px monospace';
            let yPos = 12;
            const lineHeight = 11;

            if (parts.length === 10) {
                aiVisionCtx.fillText(`H:${parts[0]}A ${parts[1]}D C:${parts[2]}A ${parts[3]}D`, 3, yPos); yPos += lineHeight;
                aiVisionCtx.fillText(`PthC:${parts[8]==='0'?'CLR':'BLK'} VisH:${parts[9]==='0'?'VIS':'HID'}`, 3, yPos); yPos += lineHeight;
                aiVisionCtx.fillText(`StN:${parts[4]} S:${parts[5]} E:${parts[6]} W:${parts[7]}`, 3, yPos); yPos += lineHeight;
            } else {
                 aiVisionCtx.fillText(stateStr.substring(0, 25), 3, yPos);  yPos += lineHeight; // Truncate long states
                 if(stateStr.length > 25) aiVisionCtx.fillText(stateStr.substring(25), 3, yPos); yPos += lineHeight;
            }

            const mapScale = 0.2; // Smaller map
            const mapOffsetX = aiVisionCanvas.width / 2 - (gameCanvas.width * mapScale / 2);
            const mapOffsetY = yPos + 5;

            aiVisionCtx.save();
            aiVisionCtx.translate(mapOffsetX, mapOffsetY);
            aiVisionCtx.scale(mapScale, mapScale);

            aiVisionCtx.globalAlpha = 0.7;
            aiVisionCtx.fillStyle = '#666'; // Darker obstacles for contrast
            obstacles.forEach(obs => aiVisionCtx.fillRect(obs.x, obs.y, obs.width, obs.height));
            if (coins.length > 0) {
                aiVisionCtx.beginPath();
                aiVisionCtx.arc(coins[0].x, coins[0].y, coins[0].radius / mapScale * 0.6 , 0, Math.PI * 2);
                aiVisionCtx.fillStyle = coins[0].color;
                aiVisionCtx.fill();
            }
            aiVisionCtx.fillStyle = hunter.color;
            aiVisionCtx.fillRect(hunter.x, hunter.y, hunter.width, hunter.height);
            aiVisionCtx.fillStyle = player.color;
            aiVisionCtx.fillRect(player.x, player.y, player.width, player.height);
            aiVisionCtx.globalAlpha = 1.0;
            aiVisionCtx.restore();
        }

        // --- Main AI Loop ---
        function aiLoop() {
            const currentState = getDiscretizedState();
            const actionToTake = chooseAction(currentState);
            
            const gameOutcome = updateGame(actionToTake); // {reward, done}
            const nextStateAfterAction = getDiscretizedState(); // State after action

            // 1. Direct RL Update
            updateQTable(currentState, actionToTake, gameOutcome.reward, nextStateAfterAction, gameOutcome.done);
            
            // 2. Model Learning
            updateModel(currentState, actionToTake, gameOutcome.reward, nextStateAfterAction);

            // 3. Planning (Dyna-Q)
            for (let i = 0; i < numPlanningSteps; i++) {
                planningStep();
            }

            drawGame();
            drawAiVision();

            if (gameOutcome.done) {
                resetGame();
            }
        }

        // --- Initialize and Start ---
        function init() {
            currentSimSpeed = parseInt(speedControl.value);
            speedValue.textContent = currentSimSpeed;
            numPlanningSteps = parseInt(planningStepsControl.value);
            planningStepsValue.textContent = numPlanningSteps;
            
            speedControl.addEventListener('input', (e) => {
                currentSimSpeed = parseInt(e.target.value);
                speedValue.textContent = currentSimSpeed;
                if (simIntervalId) clearInterval(simIntervalId);
                simIntervalId = setInterval(aiLoop, currentSimSpeed);
            });
            planningStepsControl.addEventListener('input', (e) => {
                numPlanningSteps = parseInt(e.target.value);
                planningStepsValue.textContent = numPlanningSteps;
            });
            
            resetGame();
            drawGame();
            drawAiVision();
            if (simIntervalId) clearInterval(simIntervalId);
            simIntervalId = setInterval(aiLoop, currentSimSpeed);
        }

        window.onload = init;
    </script>
</body>
</html>
