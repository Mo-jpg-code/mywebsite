<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Satellite Tracker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0a0a1a; /* Dark space blue */
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0a0a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease-out;
        }

        #loading-spinner {
            border: 8px solid #222;
            border-top: 8px solid #3498db; /* Blue accent */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        #loading-text {
            margin-top: 20px;
            font-size: 1.2em;
            color: #aaa;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(20, 20, 40, 0.85); /* Dark translucent panel */
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            max-height: 70vh;
            overflow-y: auto;
            color: #e0e0e0;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            display: none; /* Hidden by default */
            z-index: 10;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            transform: translateY(100%);
            opacity: 0;
        }
        #info-panel.visible {
            transform: translateY(0);
            opacity: 1;
        }

        #info-panel h2 {
            margin-top: 0;
            color: #58a6ff; /* Light blue title */
            font-size: 1.4em;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        #info-panel p {
            margin: 8px 0;
            font-size: 0.9em;
            line-height: 1.6;
        }
        #info-panel strong {
            color: #88c0d0; /* Lighter blue for emphasis */
        }
        #info-panel .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 1.5em;
            cursor: pointer;
            transition: color 0.2s;
        }
        #info-panel .close-button:hover {
            color: #fff;
        }

        #search-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        #search-input {
            padding: 10px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(5px);
            color: #e0e0e0;
            width: 250px;
            font-size: 0.9em;
            outline: none;
            transition: width 0.3s ease-in-out, box-shadow 0.3s ease;
        }
        #search-input:focus {
            width: 300px;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }
        #search-results {
            list-style: none;
            padding: 0;
            margin: 5px 0 0 0;
            max-height: 200px;
            overflow-y: auto;
            background-color: rgba(20, 20, 40, 0.9);
            border-radius: 5px;
            position: absolute;
            width: 100%;
        }
        #search-results li {
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 0.85em;
        }
        #search-results li:hover {
            background-color: rgba(52, 152, 219, 0.3);
        }

        #timeline-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 800px;
            background-color: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px 20px;
            z-index: 10;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            text-align: center;
        }
        #timeline-slider {
            width: 80%;
            cursor: pointer;
        }
        #time-display {
            margin-top: 5px;
            font-size: 0.9em;
            color: #ccc;
        }
        #time-controls button {
            background: rgba(52, 152, 219, 0.5);
            border: none;
            color: white;
            padding: 5px 10px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #time-controls button:hover {
            background: rgba(52, 152, 219, 0.8);
        }

        /* Scrollbar styling for info panel and search results */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(52, 152, 219, 0.5);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(52, 152, 219, 0.8);
        }

    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-spinner"></div>
        <div id="loading-text">Initializing Celestial Sphere...</div>
    </div>

    <div id="info-panel">
        <button class="close-button" onclick="hideInfoPanel()">×</button>
        <h2 id="sat-name">Satellite Name</h2>
        <p><strong>NORAD ID:</strong> <span id="sat-norad-id"></span></p>
        <p><strong>Int'l Designator:</strong> <span id="sat-intl-des"></span></p>
        <p><strong>Launch Date:</strong> <span id="sat-launch-date"></span></p>
        <p><strong>Country:</strong> <span id="sat-country"></span></p>
        <p><strong>Altitude:</strong> <span id="sat-altitude"></span> km</p>
        <p><strong>Velocity:</strong> <span id="sat-velocity"></span> km/s</p>
        <p><strong>Period:</strong> <span id="sat-period"></span> minutes</p>
        <p><strong>Latitude:</strong> <span id="sat-lat"></span>°</p>
        <p><strong>Longitude:</strong> <span id="sat-lon"></span>°</p>
    </div>

    <div id="search-container">
        <input type="text" id="search-input" placeholder="Search satellites (e.g., ISS)">
        <ul id="search-results"></ul>
    </div>

    <div id="timeline-container">
        <div id="time-controls">
            <button id="time-rewind"><<</button>
            <button id="time-play-pause">Play</button>
            <button id="time-forward">>></button>
            <button id="time-reset">Reset</button>
            <span>Speed: <span id="time-speed">1x</span></span>
        </div>
        <input type="range" id="timeline-slider" min="0" max="1440" value="0" step="1">
        <div id="time-display">Current Time: N/A</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.3/satellite.min.js"></script>

    <script>
        let scene, camera, renderer, earth, clouds, stars;
        let satellites = [];
        let satelliteObjects = new Map(); // Map NORAD ID to Three.js object
        const EARTH_RADIUS_KM = 6371;
        const SCALE_FACTOR = 1 / EARTH_RADIUS_KM; // Scale down to Three.js units (1 Earth radius = 1 unit)
        let INTERSECTED;
        let raycaster, mouse;
        let controls; // Will be OrbitControls, need to embed or link
        let loadingScreen = document.getElementById('loading-screen');
        let loadingText = document.getElementById('loading-text');
        let infoPanel = document.getElementById('info-panel');

        let searchInput = document.getElementById('search-input');
        let searchResultsList = document.getElementById('search-results');

        let currentTime = new Date();
        let timeScale = 1; // 1 = real-time, >1 = faster, <1 = slower
        let timePaused = false;
        const timelineSlider = document.getElementById('timeline-slider');
        const timeDisplay = document.getElementById('time-display');
        const timePlayPauseBtn = document.getElementById('time-play-pause');
        const timeRewindBtn = document.getElementById('time-rewind');
        const timeForwardBtn = document.getElementById('time-forward');
        const timeResetBtn = document.getElementById('time-reset');
        const timeSpeedDisplay = document.getElementById('time-speed');
        let initialTime = new Date();


        // Embed OrbitControls (simplified version for brevity or use CDN if allowed)
        // For a true single file, you'd paste the OrbitControls.js code here.
        // For this example, let's assume we can load it from CDN for development.
        // If not, this part needs manual embedding of the library.
        const orbitControlsScript = document.createElement('script');
        orbitControlsScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
        orbitControlsScript.onload = () => {
            init();
            animate();
        };
        document.head.appendChild(orbitControlsScript);


        async function init() {
            loadingText.innerText = "Setting up 3D scene...";
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1000);
            camera.position.z = 3;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Earth
            loadingText.innerText = "Loading Earth textures...";
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg', () => {
                loadingText.innerText = "Creating Earth...";
            });
            const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture });
            const earthGeometry = new THREE.SphereGeometry(1, 64, 64); // Earth radius = 1 unit
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);

            // Clouds (optional, adds realism)
            const cloudTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_2048.png', () => {
                 loadingText.innerText = "Adding atmosphere...";
            });
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64); // Slightly larger than Earth
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);

            // Stars (simple particle system)
            loadingText.innerText = "Generating starfield...";
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.005 });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(100); // Spread them far out
                const y = THREE.MathUtils.randFloatSpread(100);
                const z = THREE.MathUtils.randFloatSpread(100);
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);


            // OrbitControls (after it's loaded)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1.2; // Don't go inside the Earth
            controls.maxDistance = 50;

            // Raycasting for satellite selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onClick, false);

            // Load Satellites
            await loadSatellites();

            // Time controls
            setupTimeControls();
            updateTimeDisplay();

            // Search functionality
            searchInput.addEventListener('input', handleSearch);
            searchResultsList.addEventListener('click', handleSearchResultClick);
            document.addEventListener('click', (event) => { // Hide results if clicked outside
                if (!searchInput.contains(event.target) && !searchResultsList.contains(event.target)) {
                    searchResultsList.style.display = 'none';
                }
            });


            loadingScreen.style.opacity = '0';
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 500);

            window.addEventListener('resize', onWindowResize, false);
        }

        function setupTimeControls() {
            initialTime = new Date(currentTime); // Store the initial load time

            timelineSlider.addEventListener('input', (event) => {
                const minutesOffset = parseInt(event.target.value);
                currentTime = new Date(initialTime.getTime() + minutesOffset * 60000);
                if (timePaused) updateSatellitePositions(); // Manually update if paused
                updateTimeDisplay();
            });

            timePlayPauseBtn.addEventListener('click', () => {
                timePaused = !timePaused;
                timePlayPauseBtn.textContent = timePaused ? "Play" : "Pause";
            });

            timeRewindBtn.addEventListener('click', () => {
                timeScale = Math.max(0.1, timeScale / 2);
                updateTimeSpeedDisplay();
            });

            timeForwardBtn.addEventListener('click', () => {
                timeScale = Math.min(1024, timeScale * 2); // Max speed 1024x
                updateTimeSpeedDisplay();
            });
            
            timeResetBtn.addEventListener('click', () => {
                currentTime = new Date(initialTime);
                timeScale = 1;
                timePaused = false;
                timePlayPauseBtn.textContent = "Pause";
                timelineSlider.value = 0;
                updateTimeSpeedDisplay();
                updateTimeDisplay();
            });
        }

        function updateTimeSpeedDisplay() {
            timeSpeedDisplay.textContent = `${timeScale}x`;
        }

        function updateTimeDisplay() {
            timeDisplay.textContent = `Current Time: ${currentTime.toUTCString()}`;
            // Update slider position based on currentTime relative to initialTime
            const diffMinutes = (currentTime.getTime() - initialTime.getTime()) / 60000;
            timelineSlider.value = Math.round(Math.max(0, Math.min(1440, diffMinutes))); // Clamp to 0-1440 range
        }


        async function loadSatellites() {
            loadingText.innerText = "Fetching satellite TLE data...";
            try {
                // Using a CORS proxy for Celestrak if running locally and hitting CORS issues.
                // For production, host TLEs on your own server or use a proper API.
                const proxyUrl = 'https://cors-anywhere.herokuapp.com/'; // Simple proxy
                const tleUrl = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle';
                // const response = await fetch(proxyUrl + tleUrl);
                const response = await fetch(tleUrl); // Try direct first, proxy if fails
                
                if (!response.ok) {
                    console.error(`Failed to fetch TLEs: ${response.status} ${response.statusText}. Trying with proxy...`);
                    const proxyResponse = await fetch(proxyUrl + tleUrl);
                    if(!proxyResponse.ok) {
                         throw new Error(`Failed to fetch TLEs even with proxy: ${proxyResponse.status} ${proxyResponse.statusText}`);
                    }
                    var tleData = await proxyResponse.text();
                } else {
                    var tleData = await response.text();
                }


                loadingText.innerText = "Parsing TLE data...";
                const tleLines = tleData.trim().split('\n');
                let currentSatData = {};

                for (let i = 0; i < tleLines.length; i += 3) {
                    const name = tleLines[i].trim();
                    const tle1 = tleLines[i+1].trim();
                    const tle2 = tleLines[i+2].trim();

                    if (!name || !tle1 || !tle2) continue;

                    try {
                        const satrec = satellite.twoline2satrec(tle1, tle2);
                        // Basic metadata extraction from TLE. More detailed info usually needs separate database.
                        const noradId = tle2.substring(2, 7).trim();
                        const intlDes = tle1.substring(9, 17).trim();
                        // Year and day for launch date (approximate, from intl designator)
                        let launchYear = parseInt(intlDes.substring(0, 2));
                        launchYear += (launchYear < 57) ? 2000 : 1900; // COSPAR ID year convention
                        const launchDay = parseInt(intlDes.substring(2,5)); // Day of year
                        const launchDate = new Date(launchYear, 0); // Jan 1st of launch year
                        launchDate.setDate(launchDay);


                        satellites.push({
                            name: name,
                            satrec: satrec,
                            noradId: noradId,
                            intlDes: intlDes,
                            launchDate: launchDate.toISOString().split('T')[0],
                            // Placeholder for country, would need external db
                            country: getCountryFromIntlDes(intlDes) || "Unknown"
                        });
                    } catch (e) {
                        console.warn(`Could not parse TLE for ${name}: ${e.message}`);
                    }
                }
                loadingText.innerText = `Loaded ${satellites.length} satellites. Visualizing...`;
                createSatelliteVisuals();

            } catch (error) {
                loadingText.innerText = "Error loading satellite data. Displaying Earth only.";
                console.error("Error loading satellite data:", error);
                // Can try a fallback or local TLE data here
            }
        }
        
        function getCountryFromIntlDes(intlDes) {
            // This is a very simplified lookup. Real data is more complex.
            // Data from https://en.wikipedia.org/wiki/International_Designator
            // This is not exhaustive and just for demo.
            const prefixes = {
                'US': 'United States', 'SU': 'Russia (Soviet Union)', 'F': 'France', 'CN': 'China',
                'J': 'Japan', 'I': 'Italy', 'IN': 'India', 'CA': 'Canada', 'DE': 'Germany',
                'UK': 'United Kingdom', 'ES': 'Spain', 'AR': 'Argentina', 'BR': 'Brazil', 'AU': 'Australia',
                'KR': 'South Korea', 'IL': 'Israel', 'UAE': 'United Arab Emirates', 'EU': 'ESA'
                // ... many more
            };
            const countryCode = intlDes.substring(intlDes.length - 3, intlDes.length - 1); // Last part often indicates country
            return prefixes[countryCode.toUpperCase()] || null; // This is VERY naive
        }


        function createSatelliteVisuals() {
            const satMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00, wireframe: false }); // Bright yellow for visibility
            // For many satellites, Points or InstancedMesh is better.
            // We'll use simple spheres for a smaller set.
            const satGeometry = new THREE.SphereGeometry(0.005, 8, 8); // Small sphere

            satellites.forEach(sat => {
                const satMesh = new THREE.Mesh(satGeometry, satMaterial.clone()); // Clone material to change color on hover
                satMesh.userData = sat; // Store sat data in the mesh
                scene.add(satMesh);
                satelliteObjects.set(sat.noradId, satMesh);
            });
            updateSatellitePositions(); // Initial position update
        }

        function updateSatellitePositions() {
            if (satellites.length === 0 || timePaused && !manualUpdateCall) return;
            if (timePaused && arguments.length > 0 && arguments[0] === true) {
                // This is a manual call while paused, proceed.
            } else if (timePaused) {
                return; // Skip regular update if paused and not a manual call.
            }


            const gmst = satellite.gstime(currentTime);

            satellites.forEach(sat => {
                const satMesh = satelliteObjects.get(sat.noradId);
                if (!satMesh) return;

                try {
                    const positionAndVelocity = satellite.propagate(sat.satrec, currentTime);
                    const positionEci = positionAndVelocity.position;

                    if (!positionEci) {
                        // console.warn(`No position data for ${sat.name} at ${currentTime}`);
                        satMesh.visible = false; // Hide if propagation fails
                        return;
                    }
                    satMesh.visible = true;

                    // Convert ECI to ECF (Earth-Fixed) then to Geodetic for lat/lon/alt
                    const positionEcf = satellite.eciToEcf(positionEci, gmst);
                    const geodetic = satellite.eciToGeodetic(positionEci, gmst);

                    // Store geodetic for info panel
                    satMesh.userData.latitude = satellite.degreesLat(geodetic.latitude);
                    satMesh.userData.longitude = satellite.degreesLong(geodetic.longitude);
                    satMesh.userData.altitude = geodetic.height; // km

                    // Calculate velocity magnitude
                    const vx = positionAndVelocity.velocity.x;
                    const vy = positionAndVelocity.velocity.y;
                    const vz = positionAndVelocity.velocity.z;
                    satMesh.userData.velocity = Math.sqrt(vx*vx + vy*vy + vz*vz); // km/s

                    // Orbital period (from satrec mean motion)
                    const meanMotionRadPerMin = sat.satrec.no * 60 * 24 / (2 * Math.PI); // revs per day to rad per min
                    satMesh.userData.period = (2 * Math.PI) / sat.satrec.no; // minutes; sat.satrec.no is mean motion in radians/minute

                    // For Three.js, we need coordinates relative to Earth's center in scaled units
                    // The ECI position is already geocentric. We just need to scale and orient.
                    // Three.js Y is up, Z is towards camera by default.
                    // ECI: X towards vernal equinox, Z towards North Pole.
                    // We need to rotate ECI to align with Three.js view (ECF-like but scaled)
                    // Satellite.js ECI: (x, y, z) where z is along Earth's rotational axis.
                    // Three.js: (x, y, z) where y is typically up.
                    // So, map ECI (x,y,z) to Three.js (x, z, -y) and then apply Earth's rotation (gmst)
                    // Or, more simply, use the ECF coordinates for plotting relative to a non-rotating Earth mesh
                    // if Earth itself is rotated by GMST in the animate loop.
                    // For this demo, let's plot ECI directly and rotate the Earth mesh.

                    satMesh.position.set(
                        positionEci.x * SCALE_FACTOR,
                        positionEci.z * SCALE_FACTOR, // ECI Z (North) to Three.js Y (Up)
                        -positionEci.y * SCALE_FACTOR  // ECI Y to Three.js -Z (depth)
                    );


                } catch (e) {
                    // console.warn(`Error propagating ${sat.name}: ${e.message}`);
                    satMesh.visible = false; // Hide if error
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick(event) {
            // Check if click was on UI elements
            if (infoPanel.contains(event.target) || searchInput.contains(event.target) || searchResultsList.contains(event.target) || document.getElementById('timeline-container').contains(event.target)) {
                return; // Don't deselect if clicking UI
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(satelliteObjects.values()));

            if (intersects.length > 0) {
                const newIntersected = intersects[0].object;
                if (INTERSECTED != newIntersected) {
                    if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);

                    INTERSECTED = newIntersected;
                    INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                    INTERSECTED.material.color.setHex(0x00ff00); // Highlight green

                    displaySatelliteInfo(INTERSECTED.userData);
                    focusOnSatellite(INTERSECTED);
                }
            } else {
                if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                INTERSECTED = null;
                hideInfoPanel();
            }
        }

        function displaySatelliteInfo(satData) {
            document.getElementById('sat-name').textContent = satData.name || 'N/A';
            document.getElementById('sat-norad-id').textContent = satData.noradId || 'N/A';
            document.getElementById('sat-intl-des').textContent = satData.intlDes || 'N/A';
            document.getElementById('sat-launch-date').textContent = satData.launchDate || 'N/A';
            document.getElementById('sat-country').textContent = satData.country || 'N/A';
            document.getElementById('sat-altitude').textContent = satData.altitude ? satData.altitude.toFixed(2) : 'N/A';
            document.getElementById('sat-velocity').textContent = satData.velocity ? satData.velocity.toFixed(2) : 'N/A';
            document.getElementById('sat-period').textContent = satData.period ? satData.period.toFixed(2) : 'N/A';
            document.getElementById('sat-lat').textContent = satData.latitude ? satData.latitude.toFixed(4) : 'N/A';
            document.getElementById('sat-lon').textContent = satData.longitude ? satData.longitude.toFixed(4) : 'N/A';
            infoPanel.classList.add('visible');
        }

        function hideInfoPanel() {
            infoPanel.classList.remove('visible');
        }
        
        let targetSatellite = null;
        let isFocusing = false;

        function focusOnSatellite(satelliteObject) {
            targetSatellite = satelliteObject;
            isFocusing = true;
            // Smoothly move camera to satellite
            // controls.target.copy(satelliteObject.position); // Set new target for OrbitControls
            // The camera will then try to orbit this new target.
            // We also want to move the camera itself to a good viewing distance.
            // A simple approach:
            // camera.lookAt(satelliteObject.position); // Ensure camera is looking at it
            // And then animate camera.position
            // More robust: use controls.target and let OrbitControls handle the view.
        }

        function handleSearch(event) {
            const query = event.target.value.toLowerCase();
            searchResultsList.innerHTML = '';
            if (query.length < 2) {
                searchResultsList.style.display = 'none';
                return;
            }

            const results = satellites.filter(sat =>
                sat.name.toLowerCase().includes(query) ||
                sat.noradId.includes(query)
            ).slice(0, 10); // Limit to 10 results

            if (results.length > 0) {
                results.forEach(sat => {
                    const li = document.createElement('li');
                    li.textContent = `${sat.name} (${sat.noradId})`;
                    li.dataset.noradId = sat.noradId;
                    searchResultsList.appendChild(li);
                });
                searchResultsList.style.display = 'block';
            } else {
                searchResultsList.style.display = 'none';
            }
        }

        function handleSearchResultClick(event) {
            if (event.target.tagName === 'LI') {
                const noradId = event.target.dataset.noradId;
                const satData = satellites.find(s => s.noradId === noradId);
                const satObject = satelliteObjects.get(noradId);
                if (satData && satObject) {
                    if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    INTERSECTED = satObject;
                    INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                    INTERSECTED.material.color.setHex(0x00ff00); // Highlight green

                    displaySatelliteInfo(satData);
                    focusOnSatellite(satObject);
                    searchInput.value = satData.name; // Put full name in search bar
                    searchResultsList.style.display = 'none'; // Hide results
                }
            }
        }


        function animate() {
            requestAnimationFrame(animate);

            if (!timePaused) {
                const now = new Date();
                const elapsed = (now.getTime() - currentTime.getTime()) * timeScale;
                currentTime = new Date(currentTime.getTime() + elapsed);
                updateTimeDisplay(); // Update display based on new currentTime
                updateSatellitePositions();
            } else {
                // If paused, we might still need to update if slider moved
                // This is handled in slider event for manual update
            }


            // Earth and cloud rotation (visual, not tied to precise GMST for simplicity here)
            earth.rotation.y += 0.0001; // Slow rotation for Earth
            if (clouds) clouds.rotation.y += 0.0002; // Clouds rotate slightly faster

            if (stars) stars.rotation.y += 0.00005;

            if (controls) controls.update(); // Only if OrbitControls has been loaded

            if (isFocusing && targetSatellite) {
                // Smoothly move camera towards the satellite
                const targetPosition = new THREE.Vector3();
                targetSatellite.getWorldPosition(targetPosition); // Get world position of the satellite

                // Target for orbit controls (what the camera looks at and orbits around)
                controls.target.lerp(targetPosition, 0.05);

                // Desired camera position: offset from the satellite
                // Create a point slightly away from the satellite, in the direction of the current camera offset
                const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
                offset.normalize().multiplyScalar(0.1); // desired distance from satellite
                
                const desiredCameraPosition = new THREE.Vector3().addVectors(targetPosition, offset);
                camera.position.lerp(desiredCameraPosition, 0.05);
                
                // Stop focusing when close enough or after a certain time
                if (camera.position.distanceTo(desiredCameraPosition) < 0.01 && controls.target.distanceTo(targetPosition) < 0.01) {
                    isFocusing = false;
                    // controls.target.copy(targetPosition); // Final snap
                }
            }


            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
