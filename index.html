<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Arena (Single File)</title>
    <style>
        /* --- CSS Code --- */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Verhindert Scrollbalken */
            font-family: sans-serif;
            background-color: #f0f0f0; /* Leicht grauer Hintergrund au√üerhalb des Spiels */
        }

        #username-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .overlay-content {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .overlay-content h1 {
            margin-bottom: 20px;
        }

        .overlay-content input {
            padding: 10px;
            margin-bottom: 15px;
            width: 80%;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .overlay-content button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .overlay-content button:hover {
            background-color: #45a049;
        }


        #game-container {
            position: relative; /* Wichtig f√ºr absolute Positionierung der Spieler */
            width: 100vw;     /* Volle Breite des Viewports */
            height: 100vh;    /* Volle H√∂he des Viewports */
            background-color: white;
            cursor: crosshair; /* √Ñndert den Mauszeiger im Spielbereich */
        }

        .player {
            position: absolute;
            font-size: 30px; /* Gr√∂√üe des Emojis */
            transition: transform 0.1s ease-out; /* Kleine Animation beim Schlagen */
            user-select: none; /* Verhindert Textauswahl */
            display: flex; /* F√ºr Zentrierung von Name/Emoji */
            flex-direction: column;
            align-items: center;
        }

        .player-emoji {
            line-height: 1; /* Verhindert zus√§tzlichen Leerraum */
        }

        .player-name {
            font-size: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            white-space: nowrap; /* Verhindert Umbruch */
            margin-top: 2px;
        }

        .player.hit {
            transform: scale(1.3); /* Vergr√∂√üert beim Schlagen */
        }

        .cursor {
            position: absolute;
            font-size: 20px; /* Gr√∂√üe des Maus-Emojis */
            pointer-events: none; /* Damit man durch den Cursor klicken kann */
            user-select: none;
            z-index: 10; /* √úber anderen Spielern */
        }

        #chat-container {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 300px;
            height: 200px;
            background-color: rgba(240, 240, 240, 0.8);
            border: 1px solid #ccc;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            z-index: 50;
        }

        #chat-messages {
            flex-grow: 1;
            overflow-y: auto; /* Scrollbar wenn n√∂tig */
            padding: 5px;
            font-size: 12px;
            word-wrap: break-word; /* Lange W√∂rter umbrechen */
        }

        #chat-messages p {
            margin: 3px 0;
        }
        #chat-messages i {
            color: #555;
        }
        #chat-messages b {
             color: #333;
         }

        #chat-input-area {
            display: flex;
            border-top: 1px solid #ccc;
        }

        #chat-input {
            flex-grow: 1;
            padding: 5px;
            border: none;
            border-radius: 0 0 0 5px; /* Rundung unten links */
            outline: none;
        }

        #chat-send-button {
            padding: 5px 10px;
            background-color: #5c8dff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 0 0 5px 0; /* Rundung unten rechts */
        }
        #chat-send-button:hover {
            background-color: #4a7bde;
        }


        #kill-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 50;
        }
    </style>
</head>
<body>
    <!-- HTML Struktur -->
    <div id="username-overlay">
        <div class="overlay-content">
            <h1>W√§hle deinen Namen</h1>
            <input type="text" id="username-input" placeholder="Dein Username" maxlength="12">
            <button id="start-game-button">Spiel starten!</button>
        </div>
    </div>

    <div id="game-container">
        <!-- Spieler werden hier per JS hinzugef√ºgt -->
    </div>

    <div id="chat-container">
        <div id="chat-messages">
            <p><i>Willkommen im Emoji Arena Chat! (Lokal)</i></p>
        </div>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Nachricht tippen..." maxlength="100">
            <button id="chat-send-button">Senden</button>
        </div>
    </div>

    <div id="kill-counter">
        Kills: <span id="kill-count">0</span>
    </div>

    <script>
        // --- JavaScript Code ---

        // --- DOM Elemente ---
        const usernameOverlay = document.getElementById('username-overlay');
        const usernameInput = document.getElementById('username-input');
        const startGameButton = document.getElementById('start-game-button');
        const gameContainer = document.getElementById('game-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');
        const killCounterDisplay = document.getElementById('kill-count');

        // --- Spiel Zustand ---
        let localPlayerId = null;
        let username = "Anon";
        let players = {}; // Speichert alle Spieler { id: { x, y, mx, my, kills, emoji, name, element, cursorElement, nameElement, isHitting, isBot } }
        let keysPressed = {}; // H√§lt gedr√ºckte Tasten
        let localKills = 0;
        const playerSpeed = 5;
        const hitDistance = 50; // Wie nah man sein muss, um zu treffen (Pixel)
        const hitCooldown = 500; // Millisekunden zwischen Schl√§gen
        let canHit = true;

        const possibleEmojis = ["üòÄ", "üòé", "ü•≥", "üëΩ", "ü§ñ", "üëª", "üëæ", "ü¶ä", "üêª", "üêº", "üëë", " V "];
        const cursorEmoji = "üñ±Ô∏è"; // Oder ein anderes Emoji f√ºr den Cursor

        // --- WebSocket Simulation ---
        // ECHTE WebSocket-Verbindung w√ºrde hier initialisiert werden
        // const socket = new WebSocket('ws://dein-echter-server.de');
        // socket.onmessage = handleServerMessage;
        // function sendMessageToServer(type, data) { socket.send(JSON.stringify({ type, ...data })); }

        // --- Hilfsfunktionen ---
        function generateUniqueId() {
            return Math.random().toString(36).substring(2, 15);
        }

        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }

        // --- Spieler Erstellung / Entfernung ---
        function createPlayerElement(id, data) {
            const playerDiv = document.createElement('div');
            playerDiv.classList.add('player');
            playerDiv.id = `player-${id}`;
            playerDiv.style.left = `${data.x}px`;
            playerDiv.style.top = `${data.y}px`;

            const emojiSpan = document.createElement('span');
            emojiSpan.classList.add('player-emoji');
            emojiSpan.textContent = data.emoji;

            const nameSpan = document.createElement('span');
            nameSpan.classList.add('player-name');
            nameSpan.textContent = data.name;

            playerDiv.appendChild(emojiSpan);
            playerDiv.appendChild(nameSpan);
            gameContainer.appendChild(playerDiv);

            const cursorDiv = document.createElement('div');
            cursorDiv.classList.add('cursor');
            cursorDiv.id = `cursor-${id}`;
            cursorDiv.textContent = cursorEmoji;
            cursorDiv.style.left = `${data.mx}px`;
            cursorDiv.style.top = `${data.my}px`;
            // Eigenen Cursor nicht anzeigen, Bot-Cursor auch nicht (k√∂nnte man √§ndern)
            cursorDiv.style.display = (id === localPlayerId || data.isBot) ? 'none' : 'block';
            gameContainer.appendChild(cursorDiv);

            return { element: playerDiv, cursorElement: cursorDiv, nameElement: nameSpan };
        }

        function removePlayerElement(id) {
            const playerData = players[id];
            if (playerData) {
                playerData.element?.remove();
                playerData.cursorElement?.remove();
            }
        }

        // --- Spiel Logik ---
        function updatePlayerPosition(id, x, y) {
            const player = players[id];
            if (!player || !player.element) return;

            // Grenzen des Spielbereichs
            const containerRect = gameContainer.getBoundingClientRect();
            // Ungef√§hre Gr√∂√üe des Emojis f√ºr Kollisionserkennung am Rand
            const approxPlayerWidth = player.element.offsetWidth || 30;
            const approxPlayerHeight = player.element.offsetHeight || 30;


            player.x = Math.max(0, Math.min(containerRect.width - approxPlayerWidth, x));
            player.y = Math.max(0, Math.min(containerRect.height - approxPlayerHeight, y));

            player.element.style.left = `${player.x}px`;
            player.element.style.top = `${player.y}px`;
        }

        function updatePlayerCursor(id, mx, my) {
            const player = players[id];
            // Zeige Cursor nur f√ºr nicht-lokale, nicht-Bot Spieler an
            if (!player || !player.cursorElement || id === localPlayerId || player.isBot) return;

            player.mx = mx;
            player.my = my;
            player.cursorElement.style.left = `${mx}px`;
            player.cursorElement.style.top = `${my}px`;
        }

        function updatePlayerName(id, name) {
             const player = players[id];
             if (!player || !player.nameElement) return;
             player.name = name;
             player.nameElement.textContent = name;
        }

        function updateKillCounter() {
            killCounterDisplay.textContent = localKills;
        }

        function handleMovement() {
            if (!players[localPlayerId]) return;

            let dx = 0;
            let dy = 0;

            if (keysPressed['w'] || keysPressed['ArrowUp']) dy -= playerSpeed;
            if (keysPressed['s'] || keysPressed['ArrowDown']) dy += playerSpeed;
            if (keysPressed['a'] || keysPressed['ArrowLeft']) dx -= playerSpeed;
            if (keysPressed['d'] || keysPressed['ArrowRight']) dx += playerSpeed;

            // Diagonale Bewegung normalisieren (optional, verhindert schnelleres Laufen diagonal)
            if (dx !== 0 && dy !== 0) {
                const length = Math.sqrt(dx * dx + dy * dy);
                dx = (dx / length) * playerSpeed;
                dy = (dy / length) * playerSpeed;
            }

            if (dx !== 0 || dy !== 0) {
                const currentX = players[localPlayerId].x;
                const currentY = players[localPlayerId].y;
                updatePlayerPosition(localPlayerId, currentX + dx, currentY + dy);
                // --- SIMULATION: Sende Update an Server ---
                sendMyUpdate();
            }
        }

        function handleHit() {
            if (!canHit || !players[localPlayerId]) return;

            canHit = false;
            players[localPlayerId].element.classList.add('hit');
            players[localPlayerId].isHitting = true; // Zustand setzen

            const localPlayer = players[localPlayerId];
            let hitSomeone = false;

            // --- SIMULATION: Sende Schlag-Aktion (auch wenn nichts getroffen) ---
             sendMyUpdate(true); // 'true' signalisiert Schlag-Aktion

            for (const id in players) {
                if (id === localPlayerId) continue; // Sich selbst nicht treffen

                const targetPlayer = players[id];
                if(!targetPlayer.element) continue; // √úberspringe, wenn Element noch nicht da

                const dist = distance(localPlayer.x, localPlayer.y, targetPlayer.x, targetPlayer.y);

                if (dist < hitDistance) {
                    console.log(`Hitting player ${targetPlayer.name} (ID: ${id})`);
                    // --- SIMULATION: Sende Hit an Server ---
                    // sendMessageToServer('hit', { targetId: id });
                    // --- Direkte Simulation f√ºr Demo ---
                    // Serverseitige Logik simulieren:
                    handleServerHitConfirmation({ attackerId: localPlayerId, victimId: id });
                    hitSomeone = true;
                    // break; // Nur einen pro Klick treffen (optional)
                }
            }

            // Cooldown und Animation zur√ºcksetzen
            setTimeout(() => {
                canHit = true;
                if (players[localPlayerId]) {
                     players[localPlayerId].element.classList.remove('hit');
                     players[localPlayerId].isHitting = false; // Zustand zur√ºcksetzen
                     // --- SIMULATION: Sende Update nach Schlag-Animation ---
                     sendMyUpdate(false); // 'false' oder weglassen
                }
            }, hitCooldown);
        }

        // --- Chat Logik ---
        function addChatMessage(sender, message, isSystem = false) {
            const messageElement = document.createElement('p');
            if (isSystem) {
                messageElement.innerHTML = `<i>${message}</i>`;
            } else {
                // Sanitize message to prevent HTML injection
                const senderSpan = document.createElement('b');
                senderSpan.textContent = sender + ': ';
                messageElement.appendChild(senderSpan);
                messageElement.appendChild(document.createTextNode(message)); // Use textNode to avoid HTML parsing
            }
            chatMessages.appendChild(messageElement);
            // Auto-scroll nach unten
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message && localPlayerId && players[localPlayerId]) {
                // --- SIMULATION: Sende Chat an Server ---
                // sendMessageToServer('chat', { message: message });

                // --- Direkte Anzeige f√ºr Demo (LOKALER Chat) ---
                addChatMessage(players[localPlayerId].name, message);

                // --- SIMULATION: Sende Nachricht an alle (Bots ignorieren Chat hier) ---
                // handleServerMessage({type: 'chat', senderId: localPlayerId, message: message });

                chatInput.value = '';
            }
        }

        // Basic HTML escaping (though using textContent is safer for messages)
        function escapeHtml(unsafe) {
            if (!unsafe) return "";
            return unsafe
                 .replace(/&/g, "&")
                 .replace(/</g, "<")
                 .replace(/>/g, ">")
                 .replace(/"/g, """)
                 .replace(/'/g, "'");
        }

        // --- Event Listener ---
        function setupEventListeners() {
            // Tastatur
            window.addEventListener('keydown', (e) => {
                 // Verhindern, dass Chat-Eingabe die Bewegung ausl√∂st
                 if (document.activeElement !== chatInput) {
                    keysPressed[e.key.toLowerCase()] = true;
                 }
            });
            window.addEventListener('keyup', (e) => {
                 keysPressed[e.key.toLowerCase()] = false;
            });

            // Maus Bewegung
            gameContainer.addEventListener('mousemove', (e) => {
                if (!players[localPlayerId]) return;
                const rect = gameContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                updatePlayerCursor(localPlayerId, mouseX, mouseY); // Eigener Cursor wird nicht angezeigt, aber Position gespeichert
                // --- SIMULATION: Sende Update an Server ---
                 sendMyUpdate();
            });

            // Maus Klick (Schlagen)
            gameContainer.addEventListener('click', (e) => {
                // Verhindern, dass Klick auf Chat/Overlay schl√§gt
                if (e.target === gameContainer || e.target.classList.contains('player') || e.target.classList.contains('player-emoji')) {
                     handleHit();
                }
            });

            // Chat Senden
            chatSendButton.addEventListener('click', sendChatMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                    // Verhindern, dass Enter im Chat eine neue Zeile macht (Standardverhalten)
                    e.preventDefault();
                    // Fokus vom Input nehmen, damit WASD wieder geht (optional)
                    // chatInput.blur();
                }
            });

             // Verhindern, dass Leertaste beim Chatten scrollt
             chatInput.addEventListener('keydown', (e) => {
                 if (e.key === ' ') {
                    e.stopPropagation();
                 }
             });


            // Spiel Start
            startGameButton.addEventListener('click', startGame);
            usernameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    startGame();
                }
            });
        }

        // --- Spiel Start ---
        function startGame() {
            // Sanitize username input slightly
            username = escapeHtml(usernameInput.value.trim()) || `Anon${Math.floor(Math.random() * 100)}`;
            username = username.substring(0, 12); // Namen k√ºrzen
            if (!username) username = "Spieler"; // Fallback falls leer nach escape

            usernameOverlay.style.display = 'none'; // Overlay ausblenden

            localPlayerId = generateUniqueId();
            const startX = Math.random() * (gameContainer.clientWidth - 50);
            const startY = Math.random() * (gameContainer.clientHeight - 50);
            const startEmoji = getRandomElement(possibleEmojis);

            players[localPlayerId] = {
                x: startX,
                y: startY,
                mx: startX, // Maus startet beim Spieler
                my: startY,
                kills: 0,
                emoji: startEmoji,
                name: username,
                element: null,
                cursorElement: null,
                nameElement: null,
                isHitting: false,
                isBot: false
            };

            const elements = createPlayerElement(localPlayerId, players[localPlayerId]);
            players[localPlayerId].element = elements.element;
            players[localPlayerId].cursorElement = elements.cursorElement;
            players[localPlayerId].nameElement = elements.nameElement;
            // players[localPlayerId].cursorElement.style.display = 'none'; // Wird in createPlayerElement gehandhabt

            localKills = 0;
            updateKillCounter();
            addChatMessage(null, `Du bist als ${username} (${startEmoji}) beigetreten! Steuerung: WASD, Klick zum Schlagen.`, true);

            // --- SIMULATION: Sende "Join" Nachricht an Server ---
            // sendMessageToServer('join', { id: localPlayerId, ...players[localPlayerId] });
             // --- SIMULATION: Sende eigene Join-Nachricht lokal (f√ºr Konsistenz) ---
             // handleServerMessage({ type: 'playerJoined', id: localPlayerId, ...players[localPlayerId] }); // Nicht n√∂tig, da wir den Spieler schon erstellt haben

            // --- SIMULATION: F√ºge ein paar Dummy-Bots hinzu ---
            setTimeout(() => simulateAddBot("Bot_Alpha", "ü§ñ"), 1000);
            setTimeout(() => simulateAddBot("Bot_Beta", "üëª"), 2000);
            setTimeout(() => simulateAddBot("Guard", " V "), 3000); // Ein W√§chter-Bot

            // Starte den Game Loop
            requestAnimationFrame(gameLoop);
        }

        // --- Game Loop ---
        let lastLoopTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastLoopTime; // Zeit seit letztem Frame (f√ºr Frame-unabh√§ngige Physik/Bewegung, hier nicht voll genutzt)
            lastLoopTime = now;

            handleMovement(); // Lokale Bewegung verarbeiten

            // --- SIMULATION: Bot Bewegung ---
            simulateBotMovement(deltaTime);

            requestAnimationFrame(gameLoop);
        }

        // --- WebSocket Nachrichten Behandlung (SIMULIERT) ---

        // Simuliert das Empfangen einer Nachricht vom Server
        function handleServerMessage(data) {
            // In echt: const data = JSON.parse(message.data);
            if (!data || !data.type) {
                console.error("Sim: Invalid message received", data);
                return;
            }

            switch (data.type) {
                case 'playerJoined':
                    // F√ºge Spieler hinzu, WENN er noch nicht existiert UND nicht der lokale Spieler ist
                    if (data.id !== localPlayerId && !players[data.id]) {
                        console.log("Sim: Player joined", data);
                        // Initialisiere den Spieler-Datensatz
                        players[data.id] = {
                            x: data.x, y: data.y, mx: data.mx, my: data.my,
                            kills: data.kills || 0, emoji: data.emoji, name: data.name,
                            element: null, cursorElement: null, nameElement: null,
                            isHitting: false, isBot: data.isBot || false // Merken, ob es ein Bot ist
                        };
                        // Erstelle die DOM-Elemente
                        const elements = createPlayerElement(data.id, players[data.id]);
                        players[data.id].element = elements.element;
                        players[data.id].cursorElement = elements.cursorElement;
                        players[data.id].nameElement = elements.nameElement;

                        addChatMessage(null, `${data.name} (${data.emoji}) ist beigetreten.`, true);
                    }
                    break;
                case 'playerLeft':
                    if (data.id !== localPlayerId && players[data.id]) {
                        console.log("Sim: Player left", data);
                        addChatMessage(null, `${players[data.id].name} hat das Spiel verlassen.`, true);
                        removePlayerElement(data.id);
                        delete players[data.id];
                         // L√∂sche ggf. Bot-spezifische Daten
                         if (botTargetPositions[data.id]) {
                            delete botTargetPositions[data.id];
                        }
                    }
                    break;
                case 'playerUpdate':
                    // Aktualisiere Spieler, WENN er existiert UND nicht der lokale Spieler ist
                    if (data.id !== localPlayerId && players[data.id]) {
                        updatePlayerPosition(data.id, data.x, data.y);
                        updatePlayerCursor(data.id, data.mx, data.my); // Aktualisiert nur, wenn kein Bot

                         // Schlag-Animation anzeigen/entfernen f√ºr andere Spieler
                         const player = players[data.id];
                         if(player.element){ // Nur wenn Element existiert
                            if (data.isHitting && !player.isHitting) {
                                player.element.classList.add('hit');
                                player.isHitting = true;
                            } else if (!data.isHitting && player.isHitting) {
                                player.element.classList.remove('hit');
                                player.isHitting = false;
                            }
                        }
                    }
                    break;
                case 'chat':
                     // Zeige Chat-Nachricht an, WENN der Sender existiert UND nicht der lokale Spieler ist
                     // (Lokale Nachrichten werden schon in sendChatMessage angezeigt)
                     if (data.senderId !== localPlayerId && players[data.senderId]) {
                         console.log("Sim: Chat received", data);
                         addChatMessage(players[data.senderId].name, data.message);
                     }
                    break;
                case 'hitConfirmation': // Server best√§tigt einen Treffer
                     console.log("Sim: Hit confirmation", data);
                     handleServerHitConfirmation(data);
                     break;
                 case 'gameState': // Empfange den kompletten Zustand (z.B. beim Join)
                     console.log("Sim: Receiving full game state");
                     // L√∂sche alte Spieler (au√üer sich selbst)
                     for (const id in players) {
                         if (id !== localPlayerId) {
                             removePlayerElement(id);
                             delete players[id];
                         }
                     }
                      // F√ºge alle Spieler aus dem State hinzu
                     for (const id in data.players) {
                         if (id !== localPlayerId) {
                              handleServerMessage({ type: 'playerJoined', ...data.players[id] });
                         }
                     }
                     break;
                // Weitere Nachrichten-Typen...
            }
        }

        // Wird aufgerufen, wenn der Server (oder die Simulation) einen Treffer best√§tigt
        function handleServerHitConfirmation({ attackerId, victimId }) {
            const attacker = players[attackerId];
            const victim = players[victimId];

            // Nur fortfahren, wenn beide Spieler noch existieren
            if (!attacker || !victim || !attacker.element || !victim.element) return;

            console.log(`${attacker.name} hit ${victim.name}`);

            // Effekt auf Opfer (z.B. kurzes Blinken oder Zur√ºcksto√üen - hier nur Respawn)
            victim.element.style.opacity = '0.5'; // Kurz unsichtbar machen

             // Kills f√ºr Angreifer erh√∂hen (serverseitig passiert das)
             attacker.kills = (attacker.kills || 0) + 1;
             if (attackerId === localPlayerId) {
                 localKills = attacker.kills;
                 updateKillCounter();
             } else {
                 // Update Name des Angreifers (optional, wenn Kills angezeigt werden sollen)
                 // updatePlayerName(attackerId, `${attacker.name} [${attacker.kills}]`);
             }


            // Kills f√ºr Opfer zur√ºcksetzen
            victim.kills = 0;
            if (victimId === localPlayerId) {
                localKills = 0;
                updateKillCounter();
                addChatMessage(null, `Du wurdest von ${attacker.name} getroffen! Deine Kills wurden zur√ºckgesetzt.`, true);
            } else {
                addChatMessage(null, `${attacker.name} (${attacker.emoji}) hat ${victim.name} (${victim.emoji}) getroffen!`, true);
                 // Update Name des Opfers (optional)
                 // updatePlayerName(victimId, `${victim.name} [0]`);
            }


            // Opfer an zuf√§lliger Position respawnen nach kurzer Verz√∂gerung
            setTimeout(() => {
                 if (players[victimId] && players[victimId].element) { // Pr√ºfen ob noch vorhanden
                     const respawnX = Math.random() * (gameContainer.clientWidth - 50);
                     const respawnY = Math.random() * (gameContainer.clientHeight - 50);
                     updatePlayerPosition(victimId, respawnX, respawnY);
                     players[victimId].element.style.opacity = '1'; // Wieder sichtbar machen

                     // --- SIMULATION: Server w√ºrde dieses Positions-Update senden ---
                     // handleServerMessage({type: 'playerUpdate', id: victimId, x: respawnX, y: respawnY, mx: victim.mx, my: victim.my, isHitting: false});
                }
            }, 200); // 200ms Verz√∂gerung f√ºr den Effekt
        }


        // Simuliert das Senden des eigenen Zustands an den Server
        let lastUpdateTime = 0;
        const updateInterval = 50; // Send update max every 50ms (~20 updates/sec)

        function sendMyUpdate(forceSend = false) {
            const now = Date.now();
            // Sende nur, wenn genug Zeit vergangen ist ODER wenn es ein wichtiges Update ist (forceSend, z.B. Schlag)
            if (!localPlayerId || (!forceSend && now - lastUpdateTime < updateInterval)) {
                return;
            }
            lastUpdateTime = now;

            const localPlayer = players[localPlayerId];
            if (!localPlayer) return; // Sicherheitshalber

            const data = {
                // type: 'playerUpdate', // In einer echten WS-Nachricht n√∂tig
                id: localPlayerId,
                x: localPlayer.x,
                y: localPlayer.y,
                mx: localPlayer.mx,
                my: localPlayer.my,
                isHitting: localPlayer.isHitting // Sendet den aktuellen Schlag-Status
            };
             // --- SIMULATION: Senden an Server ---
             // sendMessageToServer('playerUpdate', data);

             // --- SIMULATION: Empfange Updates von anderen (Bots) ---
             // In einer echten Anwendung k√§men diese Updates vom Server.
             // Hier rufen wir nur die Bot-Logik auf, die dann `handleServerMessage` f√ºr die Bots ausl√∂st.
             // simulateBotMovement() ist jetzt im gameLoop.
        }

        // --- Bot Simulation (Nur f√ºr Demo-Zwecke) ---
        let botTargetPositions = {}; // Speichert { botId: { x, y } }
        let botWaitUntil = {}; // Speichert { botId: timestamp } wann der Bot wieder laufen darf

        function simulateAddBot(name, emoji) {
            const botId = generateUniqueId();
            const botData = {
                id: botId,
                x: Math.random() * (gameContainer.clientWidth - 50),
                y: Math.random() * (gameContainer.clientHeight - 50),
                mx: 0, my: 0, // Bots haben keine Maus
                kills: 0,
                emoji: emoji,
                name: name,
                isBot: true
            };
            // Simuliere "playerJoined" Nachricht vom Server
            handleServerMessage({ type: 'playerJoined', ...botData });
            // Setze initiales Ziel f√ºr den Bot
             botTargetPositions[botId] = {
                 x: Math.random() * (gameContainer.clientWidth - 50),
                 y: Math.random() * (gameContainer.clientHeight - 50)
             };
            botWaitUntil[botId] = 0; // Startet sofort
        }

        function simulateBotMovement(deltaTime) {
            const botSpeed = 1.5 + Math.random() * 0.5; // Leicht variable Geschwindigkeit
            const now = Date.now();

            for (const id in players) {
                if (players[id]?.isBot) { // Nur wenn Bot und existiert
                    const bot = players[id];

                     // √úberspringen, wenn Bot gerade wartet
                     if (now < (botWaitUntil[id] || 0)) {
                         continue;
                     }

                    let target = botTargetPositions[id];

                    // Wenn kein Ziel oder Ziel erreicht, neues Ziel setzen und kurz warten
                    if (!target || distance(bot.x, bot.y, target.x, target.y) < 15) {
                         botTargetPositions[id] = {
                             x: Math.random() * (gameContainer.clientWidth - 50),
                             y: Math.random() * (gameContainer.clientHeight - 50)
                         };
                         target = botTargetPositions[id];
                         // Warte 0.5 bis 2 Sekunden
                         botWaitUntil[id] = now + 500 + Math.random() * 1500;
                         continue; // N√§chste Iteration abwarten
                    }

                    // Einfache Bewegung Richtung Ziel (deltaTime nicht wirklich genutzt hier, feste Geschwindigkeit)
                    const angle = Math.atan2(target.y - bot.y, target.x - bot.x);
                    const dx = Math.cos(angle) * botSpeed;
                    const dy = Math.sin(angle) * botSpeed;

                    const newX = bot.x + dx;
                    const newY = bot.y + dy;

                    // Simuliere eine "playerUpdate"-Nachricht F√úR diesen Bot
                    // Diese wird dann von handleServerMessage verarbeitet, um den Bot im Spiel zu bewegen
                    handleServerMessage({
                        type: 'playerUpdate',
                        id: id,
                        x: newX,
                        y: newY,
                        mx: bot.mx, // Bleibt 0
                        my: bot.my, // Bleibt 0
                        isHitting: false // Bots schlagen hier nicht (k√∂nnte man einbauen)
                    });
                }
            }
        }


        // --- Initialisierung ---
        setupEventListeners();
        // Das Spiel wird durch den Klick auf "Spiel starten!" gestartet (ruft startGame auf)

    </script>
</body>
</html>
