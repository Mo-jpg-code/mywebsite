<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Micro Flight Simulator</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #111;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Prevent default touch behaviors like pinch-zoom */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px; /* Max width for larger screens */
            height: 100%;
            background-color: #222;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #canvas-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Canvas takes available vertical space */
            background-color: #000;
            overflow: hidden; /* Crucial for camera */
        }

        canvas {
            display: block;
            background-color: #334466; /* Sky blue */
        }
        
        #ui-panel {
            display: flex;
            flex-direction: column;
            width: 100%;
            background-color: #333;
            padding: 5px 0;
            box-sizing: border-box;
        }

        .controls-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px 10px;
        }

        .controls-row button, .controls-row input[type="range"] {
            padding: 8px 12px;
            margin: 2px;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .controls-row input[type="range"] {
            flex-grow: 1;
            max-width: 150px;
        }

        .controls-row button:active {
            background-color: #777;
        }
        .controls-row label {
            font-size: 0.8em;
            margin-right: 5px;
        }

        #telemetry {
            font-size: 0.8em;
            text-align: center;
            padding: 3px;
            background-color: #2a2a2a;
        }
        
        /* Build Mode Specific UI */
        #part-palette {
            display: flex;
            flex-wrap: wrap; /* Allow parts to wrap */
            justify-content: center;
            padding: 5px;
            background-color: #282828;
            max-height: 150px; /* Limit palette height */
            overflow-y: auto;
        }

        .part-button {
            border: 1px solid #666;
            background-color: #444;
            color: white;
            padding: 5px;
            margin: 3px;
            cursor: pointer;
            min-width: 60px;
            text-align: center;
            font-size: 0.7em;
            border-radius: 3px;
        }
        .part-button.selected {
            background-color: #007bff;
            border-color: #0056b3;
        }

        #staging-ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            background-color: #2c2c2c;
        }
        #staging-ui h4 { margin: 2px 0 5px 0; font-size: 0.8em;}
        .stage-container {
            border: 1px dashed #555;
            padding: 3px;
            margin-bottom: 3px;
            width: 90%;
            min-height: 20px;
            font-size: 0.7em;
        }
        .stage-part {
            background-color: #383838;
            padding: 2px;
            margin: 1px;
            border-radius: 2px;
            font-size: 0.9em; /* relative to parent */
        }

        #build-mode-controls button, #flight-mode-controls button {
            flex-grow: 1;
        }

        /* Utility */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <div id="ui-panel">
            <div id="telemetry">Alt: 0m | Vel: 0m/s | Fuel: 100% | Stage: 0</div>

            <!-- Build Mode UI -->
            <div id="build-mode-ui">
                <div id="part-palette"></div>
                <div id="staging-ui">
                    <h4>Staging</h4>
                    <div id="stages-display"></div>
                    <div class="controls-row">
                        <button id="addStageBtn">Add Stage</button>
                        <button id="clearRocketBtn">Clear Rocket</button>
                    </div>
                </div>
                <div class="controls-row" id="build-mode-controls">
                    <button id="launchBtn">Launch!</button>
                </div>
            </div>

            <!-- Flight Mode UI -->
            <div id="flight-mode-ui" class="hidden">
                 <div class="controls-row">
                    <label for="throttleSlider">Throttle:</label>
                    <input type="range" id="throttleSlider" min="0" max="100" value="0">
                    <span id="throttleValue">0%</span>
                </div>
                <div class="controls-row" id="flight-mode-controls">
                    <button id="stageBtn">Stage!</button>
                    <button id="resetFlightBtn">To Builder</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game Constants
        const PX_PER_METER = 5; // Pixels per meter for drawing
        const GRAVITY = 9.81;   // m/s^2
        const TIME_STEP = 1/60; // s, for physics updates

        // Canvas and Context
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const telemetryDisplay = document.getElementById('telemetry');
        const partPaletteDiv = document.getElementById('part-palette');
        const stagesDisplayDiv = document.getElementById('stages-display');
        const addStageBtn = document.getElementById('addStageBtn');
        const clearRocketBtn = document.getElementById('clearRocketBtn');
        const launchBtn = document.getElementById('launchBtn');
        const throttleSlider = document.getElementById('throttleSlider');
        const throttleValueSpan = document.getElementById('throttleValue');
        const stageBtn = document.getElementById('stageBtn');
        const resetFlightBtn = document.getElementById('resetFlightBtn');
        const buildModeUI = document.getElementById('build-mode-ui');
        const flightModeUI = document.getElementById('flight-mode-ui');
        
        // Game State
        let gameState = 'BUILD'; // BUILD or FLIGHT
        let cameraY = 0; // For scrolling the view during flight
        let rocket = {
            parts: [],       // { def, x, y, stageIndex, instanceId }
            stages: [[]],    // Array of arrays of part instanceIds
            currentStageIndex: 0,
            width: 0,        // Max width of the rocket
            totalMass: 0,    // kg
            totalFuel: 0,    // units
            currentFuel: 0,  // units
            thrust: 0,       // N
            throttle: 0,     // 0-1
            altitude: 0,     // m
            velocityY: 0,    // m/s
            centerOfMassY: 0 // Relative to bottom of rocket
        };
        let nextPartInstanceId = 0;

        // Part Definitions
        const PART_DEFINITIONS = {
            // Dimensions in meters, mass in kg, fuel in "units" (e.g., liters or kg)
            // ISP in seconds (simplified efficiency metric)
            // Connection points: 'top', 'bottom', 'side' (not used yet)
            // spriteColor: color for drawing
            // type: 'pod', 'tank', 'engine', 'decoupler' (decoupler not fully implemented)
            commandPod: { 
                name: 'Command Pod', type: 'pod', 
                width: 2, height: 1.5, mass: 500, 
                spriteColor: '#cccccc', connectionPoints: ['bottom'] 
            },
            smallTank: { 
                name: 'Small Tank', type: 'tank', 
                width: 2, height: 2, mass: 100, fuel: 800, 
                spriteColor: '#aaaaaa', connectionPoints: ['top', 'bottom']
            },
            mediumTank: {
                name: 'Medium Tank', type: 'tank',
                width: 3, height: 4, mass: 200, fuel: 2000,
                spriteColor: '#bbbbbb', connectionPoints: ['top', 'bottom']
            },
            smallEngine: { 
                name: 'Small Engine', type: 'engine', 
                width: 1.5, height: 1.2, mass: 150, baseThrust: 40000, isp: 280, 
                spriteColor: '#888888', connectionPoints: ['top'] 
            },
            largeEngine: {
                name: 'Large Engine', type: 'engine',
                width: 2.8, height: 2.5, mass: 800, baseThrust: 250000, isp: 310,
                spriteColor: '#777777', connectionPoints: ['top']
            }
        };
        let selectedPartKey = null;

        // --- Utility Functions ---
        function resizeCanvas() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            draw(); // Redraw after resize
        }

        function getPartById(instanceId) {
            return rocket.parts.find(p => p.instanceId === instanceId);
        }
        
        function getPartDefinition(partKey) {
            return PART_DEFINITIONS[partKey];
        }

        // --- Build Mode Logic ---
        function populatePartPalette() {
            partPaletteDiv.innerHTML = '';
            for (const key in PART_DEFINITIONS) {
                const partDef = PART_DEFINITIONS[key];
                const button = document.createElement('button');
                button.classList.add('part-button');
                button.textContent = partDef.name;
                button.dataset.partKey = key;
                button.onclick = () => selectPart(key, button);
                partPaletteDiv.appendChild(button);
            }
        }

        function selectPart(partKey, buttonElement) {
            selectedPartKey = partKey;
            document.querySelectorAll('.part-button.selected').forEach(btn => btn.classList.remove('selected'));
            if (buttonElement) buttonElement.classList.add('selected');
        }

        function addPartToRocket(partDefKey, attachToInstanceId = null, clickYCanvas) {
            if (!partDefKey) return;
            const partDef = getPartDefinition(partDefKey);
            let newPartY = 0; // Relative y from bottom of rocket
            let newPartXOffset = 0; // For now, centered

            if (rocket.parts.length === 0) {
                if (partDef.type !== 'pod' && partDef.type !== 'engine') { // First part usually pod or engine if building upwards
                     // Allow any part as first part for simplicity in this demo
                }
            } else {
                const attachToPart = attachToInstanceId ? getPartById(attachToInstanceId) : rocket.parts[rocket.parts.length - 1];
                if (!attachToPart) {
                    console.error("Cannot find part to attach to.");
                    return;
                }
                const attachToDef = getPartDefinition(attachToPart.def);
                
                // Simple stacking: new part goes on top of attachToPart
                newPartY = attachToPart.y + attachToDef.height;
            }

            const newPart = {
                def: partDefKey,
                x: newPartXOffset, // X is relative to rocket centerline (0 for now)
                y: newPartY,       // Y is relative to rocket bottom (0)
                stageIndex: rocket.stages.length - 1, // Add to current last stage by default
                instanceId: nextPartInstanceId++
            };
            rocket.parts.push(newPart);
            rocket.stages[newPart.stageIndex].push(newPart.instanceId);
            
            // Sort parts by Y for drawing and CoM calculation
            rocket.parts.sort((a, b) => a.y - b.y); 
            
            calculateRocketProperties();
            updateStagingUI();
            draw();
        }

        function calculateRocketProperties() {
            rocket.totalMass = 0;
            rocket.totalFuel = 0;
            let weightedMassSumY = 0;
            rocket.width = 0;

            rocket.parts.forEach(partInstance => {
                const def = getPartDefinition(partInstance.def);
                rocket.totalMass += def.mass;
                if (def.fuel) rocket.totalFuel += def.fuel;
                // For CoM, y is part's bottom. Use center of part for CoM calc.
                weightedMassSumY += def.mass * (partInstance.y + def.height / 2);
                if (def.width > rocket.width) rocket.width = def.width;
            });
            rocket.currentFuel = rocket.totalFuel;
            if (rocket.totalMass > 0) {
                rocket.centerOfMassY = weightedMassSumY / rocket.totalMass;
            } else {
                rocket.centerOfMassY = 0;
            }
        }

        function clearRocket() {
            rocket.parts = [];
            rocket.stages = [[]]; // Reset to one empty stage
            rocket.currentStageIndex = 0;
            calculateRocketProperties();
            updateStagingUI();
            nextPartInstanceId = 0;
            cameraY = 0; // Reset camera for build mode
            draw();
        }

        // --- Staging UI Logic ---
        function updateStagingUI() {
            stagesDisplayDiv.innerHTML = '';
            rocket.stages.forEach((stagePartsInstanceIds, stageIdx) => {
                const stageDiv = document.createElement('div');
                stageDiv.classList.add('stage-container');
                stageDiv.innerHTML = `<strong>Stage ${stageIdx}</strong> ${stageIdx === rocket.currentStageIndex && gameState === 'FLIGHT' ? "(Active)" : ""}`;
                
                stagePartsInstanceIds.forEach(instanceId => {
                    const partInstance = getPartById(instanceId);
                    if (partInstance) {
                        const partDef = getPartDefinition(partInstance.def);
                        const partElement = document.createElement('div');
                        partElement.classList.add('stage-part');
                        partElement.textContent = `${partDef.name} (ID: ${instanceId})`;
                        
                        // Allow moving parts between stages (simplified)
                        partElement.onclick = () => {
                            if (gameState === 'BUILD') promptMovePartStage(instanceId, stageIdx);
                        };
                        stageDiv.appendChild(partElement);
                    }
                });
                stagesDisplayDiv.appendChild(stageDiv);
            });
        }

        function promptMovePartStage(instanceId, currentStageIdx) {
            const newStage = prompt(`Move part ID ${instanceId} to stage (0-${rocket.stages.length - 1}):`, currentStageIdx);
            if (newStage !== null) {
                const targetStageIdx = parseInt(newStage);
                if (!isNaN(targetStageIdx) && targetStageIdx >= 0 && targetStageIdx < rocket.stages.length) {
                    // Remove from old stage
                    rocket.stages[currentStageIdx] = rocket.stages[currentStageIdx].filter(id => id !== instanceId);
                    // Add to new stage
                    rocket.stages[targetStageIdx].push(instanceId);
                    getPartById(instanceId).stageIndex = targetStageIdx; // Update part's stageIndex
                    updateStagingUI();
                    calculateRocketProperties(); // Recalculate if staging affects active engines etc. (not critical now)
                } else {
                    alert('Invalid stage number.');
                }
            }
        }
        
        addStageBtn.onclick = () => {
            if (gameState === 'BUILD') {
                rocket.stages.push([]);
                updateStagingUI();
            }
        };

        // --- Flight Mode Logic ---
        function switchToFlightMode() {
            if (rocket.parts.length === 0) {
                alert("Build a rocket first!");
                return;
            }
            gameState = 'FLIGHT';
            buildModeUI.classList.add('hidden');
            flightModeUI.classList.remove('hidden');
            
            // Reset flight parameters
            rocket.altitude = 0;
            rocket.velocityY = 0;
            rocket.currentStageIndex = findFirstStageWithEngines(); // Start with the first stage that can do something
            rocket.currentFuel = rocket.totalFuel; // Reset fuel
            throttleSlider.value = 0; // Reset throttle
            rocket.throttle = 0;
            updateThrottleDisplay();
            calculateActiveThrust(); // Initial thrust calculation
            updateStagingUI(); // To show "(Active)" on current stage
            gameLoop(); // Start the physics and rendering loop for flight
        }

        function findFirstStageWithEngines() {
            for(let i = rocket.stages.length -1; i >= 0; i--) {
                const stageHasEngine = rocket.stages[i].some(id => {
                    const part = getPartById(id);
                    return part && getPartDefinition(part.def).type === 'engine';
                });
                if (stageHasEngine) return i;
            }
            return rocket.stages.length - 1; // Default to last stage if no engines (it won't fly)
        }


        function switchToBuildMode() {
            gameState = 'BUILD';
            flightModeUI.classList.add('hidden');
            buildModeUI.classList.remove('hidden');
            rocket.currentStageIndex = rocket.stages.length -1; // Reset to last stage for building
            updateStagingUI(); // Remove "(Active)"
            cameraY = 0; // Reset camera for build mode
            draw(); // Redraw for build mode
        }

        function updatePhysics(dt) {
            if (rocket.parts.length === 0 || rocket.totalMass <= 0) {
                rocket.velocityY = 0; // Fall if no mass (shouldn't happen with parts)
                if(rocket.altitude <=0) rocket.altitude = 0; else rocket.velocityY -= GRAVITY * dt;
                return;
            }

            // Calculate forces
            const thrustForce = rocket.thrust * rocket.throttle;
            const gravityForce = rocket.totalMass * GRAVITY;
            const netForce = thrustForce - gravityForce;

            // Update acceleration, velocity, altitude
            const acceleration = netForce / rocket.totalMass;
            rocket.velocityY += acceleration * dt;
            rocket.altitude += rocket.velocityY * dt;

            // Fuel consumption
            let fuelConsumedThisTick = 0;
            rocket.parts.forEach(partInstance => {
                const def = getPartDefinition(partInstance.def);
                if (def.type === 'engine' && partInstance.stageIndex === rocket.currentStageIndex && rocket.currentFuel > 0) {
                    // Simplified fuel consumption: proportional to thrust and throttle
                    // Real SFS: F = mdot * Ve;  mdot = F / (Isp * g0)
                    // Here, let's link it to baseThrust and isp more directly (but still simplified)
                    const fuelRate = (def.baseThrust / (def.isp * GRAVITY)) * rocket.throttle; // kg/s if fuel was mass
                    // Since fuel is "units", let's scale it: assume 1 fuel unit = 1kg for this calc
                    fuelConsumedThisTick += fuelRate * dt;
                }
            });
            
            rocket.currentFuel -= fuelConsumedThisTick;
            if (rocket.currentFuel < 0) rocket.currentFuel = 0;

            // If out of fuel, engines in current stage stop producing thrust
            if (rocket.currentFuel <= 0) {
                calculateActiveThrust(); // This will set thrust to 0 if fuel is out for active engines
            }
            
            // Ground collision
            if (rocket.altitude < 0) {
                rocket.altitude = 0;
                rocket.velocityY = 0;
                // Potentially end flight or destroy rocket here
                // For now, just stop at ground
            }
        }
        
        function calculateActiveThrust() {
            rocket.thrust = 0;
            if (rocket.currentFuel <= 0) return; // No thrust if no fuel globally

            rocket.stages[rocket.currentStageIndex]?.forEach(instanceId => {
                const partInstance = getPartById(instanceId);
                if (partInstance) {
                    const def = getPartDefinition(partInstance.def);
                    if (def.type === 'engine') {
                        rocket.thrust += def.baseThrust;
                    }
                }
            });
        }

        function activateNextStage() {
            if (rocket.currentStageIndex <= 0) { // Already at the last (numerically smallest) stage
                console.log("No more stages or already at stage 0.");
                 // Deactivate engines in stage 0 if it's the only one left
                if (rocket.currentStageIndex === 0) {
                    rocket.thrust = 0; // Effectively turns off engines if staging at stage 0
                }
                return;
            }

            // "Jettison" parts from the current stage (and all stages above it numerically)
            // In SFS, staging usually separates below. Here, higher index means "earlier" stage.
            // So, when staging from stage K, parts in stage K are effectively jettisoned.
            const partsToKeep = [];
            let massJettisoned = 0;
            let fuelJettisoned = 0;

            rocket.parts.forEach(p => {
                if (p.stageIndex < rocket.currentStageIndex) { // Keep parts in stages numerically smaller (later stages)
                    partsToKeep.push(p);
                } else {
                    const def = getPartDefinition(p.def);
                    massJettisoned += def.mass;
                    if (def.fuel) { // Only count fuel from jettisoned tanks
                        // This fuel is lost. We need to track which fuel belongs to which tank.
                        // Simplification: assume fuel is drawn proportionally or from specific tanks.
                        // For now, just reduce totalMass. Fuel logic is tricky with shared pools.
                        // Let's assume for simplicity that fuel in jettisoned tanks is lost.
                        // This requires a more complex fuel model, which is too much for this demo.
                        // For now, global fuel pool remains, but mass reduces.
                    }
                }
            });
            rocket.parts = partsToKeep;
            rocket.totalMass -= massJettisoned; // This is crucial
            // rocket.currentFuel might need adjustment if we tracked fuel per tank.

            rocket.currentStageIndex--; // Move to the next (numerically smaller) stage

            // Recalculate properties based on remaining parts
            calculateRocketProperties(); // This re-sums mass and fuel from *remaining* parts
                                         // It implicitly handles "losing" fuel from detached tanks.

            calculateActiveThrust();   // Update thrust from newly activated engines
            updateStagingUI();         // Update visual display
            console.log(`Staged! Now at stage ${rocket.currentStageIndex}. Mass: ${rocket.totalMass.toFixed(0)}kg`);
        }


        // --- Drawing ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background (simple gradient or color)
            const groundLevelCanvas = canvas.height - 50 + cameraY; // Ground position in canvas space
            
            // Sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#334477'); // Darker blue higher up
            skyGradient.addColorStop(0.7, '#6688CC'); // Lighter blue near horizon
            skyGradient.addColorStop(1, '#55AA55'); // Ground hint
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ground
            ctx.fillStyle = '#448844'; // Green
            ctx.fillRect(0, groundLevelCanvas, canvas.width, canvas.height - groundLevelCanvas);

            // Launchpad (only in build mode or at low altitude)
            if (gameState === 'BUILD' || rocket.altitude < 100) {
                const launchpadHeight = 10 * PX_PER_METER;
                const launchpadY = groundLevelCanvas - launchpadHeight;
                ctx.fillStyle = '#666666';
                ctx.fillRect(canvas.width / 2 - 20 * PX_PER_METER, launchpadY, 40 * PX_PER_METER, launchpadHeight);
            }

            // Draw Rocket
            ctx.save();
            // Center rocket horizontally. Vertically, rocket bottom is at altitude, adjusted by camera.
            const rocketBaseYCanvas = groundLevelCanvas - (rocket.altitude * PX_PER_METER);
            ctx.translate(canvas.width / 2, rocketBaseYCanvas);

            rocket.parts.forEach(partInstance => {
                const def = getPartDefinition(partInstance.def);
                const partX = (partInstance.x - def.width / 2) * PX_PER_METER; // Center part on its x
                const partY = -(partInstance.y + def.height) * PX_PER_METER; // Y is up, canvas Y is down
                
                ctx.fillStyle = def.spriteColor;
                ctx.fillRect(partX, partY, def.width * PX_PER_METER, def.height * PX_PER_METER);
                
                // Outline
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(partX, partY, def.width * PX_PER_METER, def.height * PX_PER_METER);

                // Draw flame for active engines
                if (gameState === 'FLIGHT' && def.type === 'engine' && 
                    partInstance.stageIndex === rocket.currentStageIndex && 
                    rocket.throttle > 0 && rocket.currentFuel > 0) {
                    const flameLength = (def.height * 1.5 * rocket.throttle) * PX_PER_METER;
                    const flameWidth = (def.width * 0.8) * PX_PER_METER;
                    ctx.fillStyle = `rgba(255, ${Math.random()*150+100}, 0, ${0.5 + rocket.throttle * 0.5})`;
                    // Flame starts at bottom of engine (partY + def.height * PX_PER_METER)
                    ctx.beginPath();
                    ctx.moveTo(partX + (def.width * PX_PER_METER - flameWidth) / 2, partY + def.height * PX_PER_METER);
                    ctx.lineTo(partX + (def.width * PX_PER_METER + flameWidth) / 2, partY + def.height * PX_PER_METER);
                    ctx.lineTo(partX + def.width * PX_PER_METER / 2, partY + def.height * PX_PER_METER + flameLength);
                    ctx.closePath();
                    ctx.fill();
                }
            });
            ctx.restore();

            // Draw selection preview in build mode
            if (gameState === 'BUILD' && selectedPartKey && tempMousePosCanvas) {
                const partDef = getPartDefinition(selectedPartKey);
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = partDef.spriteColor;
                
                // Attempt to snap
                let placeYCanvas = tempMousePosCanvas.y;
                let attachToPart = null;
                const snapThreshold = 20; // pixels

                // Rocket drawn from groundLevelCanvas up. Mouse Y relative to canvas top.
                // Rocket parts y are relative to rocket bottom.
                // Convert canvas click Y to rocket-relative Y for snapping
                const clickYRocketRelativeMeters = (groundLevelCanvas - tempMousePosCanvas.y) / PX_PER_METER;

                let finalPlaceY_rocketMeters = 0; // Y coord for the bottom of the new part, in rocket space

                if (rocket.parts.length > 0) {
                    let bestSnap = null;
                    let minDistance = Infinity;

                    rocket.parts.forEach(p => {
                        const pDef = getPartDefinition(p.def);
                        // Snap to top of existing part
                        const topOfExistingPartYRocketMeters = p.y + pDef.height;
                        const dist = Math.abs(clickYRocketRelativeMeters - topOfExistingPartYRocketMeters);

                        if (dist < (pDef.height/2 + partDef.height/2) * 1.5 && dist < minDistance ) { // Crude proximity and connection logic
                            // Check if connection is valid (e.g., engine on tank bottom)
                            // For simplicity, allow most connections
                            if (pDef.connectionPoints.includes('top') && partDef.connectionPoints.includes('bottom')) {
                                minDistance = dist;
                                bestSnap = p;
                            }
                        }
                    });
                    
                    if (bestSnap) {
                        const bestSnapDef = getPartDefinition(bestSnap.def);
                        finalPlaceY_rocketMeters = bestSnap.y + bestSnapDef.height;
                        currentSnapTargetId = bestSnap.instanceId;
                    } else {
                        // No snap, place freely (or at base if first part)
                        finalPlaceY_rocketMeters = Math.max(0, clickYRocketRelativeMeters - partDef.height / 2);
                        currentSnapTargetId = null;
                    }

                } else { // First part
                    finalPlaceY_rocketMeters = 0; // Place at rocket bottom
                    currentSnapTargetId = null;
                }

                // Convert back to canvas Y for drawing preview
                const previewBottomCanvasY = groundLevelCanvas - (finalPlaceY_rocketMeters * PX_PER_METER);
                const previewTopCanvasY = previewBottomCanvasY - (partDef.height * PX_PER_METER);

                ctx.fillRect(
                    canvas.width / 2 - (partDef.width / 2 * PX_PER_METER),
                    previewTopCanvasY,
                    partDef.width * PX_PER_METER,
                    partDef.height * PX_PER_METER
                );
                ctx.strokeStyle = '#FFF';
                ctx.strokeRect(
                    canvas.width / 2 - (partDef.width / 2 * PX_PER_METER),
                    previewTopCanvasY,
                    partDef.width * PX_PER_METER,
                    partDef.height * PX_PER_METER
                );
                ctx.restore();
            }
        }
        
        let currentSnapTargetId = null; // Used by canvas click to know which part it snapped to

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState !== 'FLIGHT') return; // Only run loop in flight mode

            const deltaTime = (timestamp - lastTime) / 1000 || TIME_STEP; // ms to s
            lastTime = timestamp;

            // Fixed time step for physics stability
            let accumulatedTime = deltaTime;
            while (accumulatedTime >= TIME_STEP) {
                updatePhysics(TIME_STEP);
                accumulatedTime -= TIME_STEP;
            }
            if (accumulatedTime > 0) { // Handle remaining time
                 updatePhysics(accumulatedTime);
            }

            // Update camera to follow rocket's Center of Mass
            // Rocket's CoM in meters from ground: rocket.altitude + rocket.centerOfMassY
            // We want CoM to be roughly at, say, 1/3 from bottom of screen.
            const targetCameraY = (rocket.altitude + rocket.centerOfMassY) * PX_PER_METER - canvas.height * 2/3;
            cameraY += (targetCameraY - cameraY) * 0.1; // Smooth camera motion

            updateTelemetry();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function updateTelemetry() {
            const fuelPercent = rocket.totalFuel > 0 ? (rocket.currentFuel / rocket.totalFuel * 100).toFixed(0) : 0;
            telemetryDisplay.textContent = 
                `Alt: ${rocket.altitude.toFixed(0)}m | Vel: ${rocket.velocityY.toFixed(1)}m/s | Fuel: ${fuelPercent}% | Stage: ${rocket.currentStageIndex}`;
        }

        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);

        // Mouse/Touch on Canvas for Part Placement
        let tempMousePosCanvas = null; // For drawing preview part

        function handleCanvasInteraction(event) {
            if (gameState !== 'BUILD' || !selectedPartKey) return;
            event.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            // In build mode, click adds the part. Snapping logic is in draw() for preview,
            // and here we use the determined snap target.
            if (event.type === 'mousedown' || event.type === 'touchstart') {
                addPartToRocket(selectedPartKey, currentSnapTargetId, canvasY); // Pass currentSnapTargetId determined by draw preview
                // Optionally, deselect part after placing:
                // selectPart(null, null); 
            }
        }
        
        function handleCanvasMove(event) {
            if (gameState !== 'BUILD' || !selectedPartKey) {
                tempMousePosCanvas = null; // Clear if not relevant
                return;
            }
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            tempMousePosCanvas = { x: clientX - rect.left, y: clientY - rect.top };
            draw(); // Redraw to show part preview at mouse
        }

        canvas.addEventListener('mousedown', handleCanvasInteraction);
        canvas.addEventListener('mousemove', handleCanvasMove);
        canvas.addEventListener('touchstart', handleCanvasInteraction, { passive: false });
        canvas.addEventListener('touchmove', handleCanvasMove, { passive: false });


        // UI Button Listeners
        launchBtn.onclick = switchToFlightMode;
        resetFlightBtn.onclick = switchToBuildMode;
        clearRocketBtn.onclick = clearRocket;

        throttleSlider.oninput = () => {
            rocket.throttle = parseInt(throttleSlider.value) / 100;
            updateThrottleDisplay();
            if (gameState === 'FLIGHT') { // Only recalculate thrust if in flight
                calculateActiveThrust(); // Recalculate based on new throttle potentially affecting fuel use logic
            }
        };
        
        function updateThrottleDisplay() {
            throttleValueSpan.textContent = `${(rocket.throttle * 100).toFixed(0)}%`;
        }

        stageBtn.onclick = () => {
            if (gameState === 'FLIGHT') {
                activateNextStage();
            }
        };

        // --- Initialization ---
        function init() {
            populatePartPalette();
            selectPart('commandPod', partPaletteDiv.querySelector('[data-part-key="commandPod"]')); // Select pod by default
            resizeCanvas(); // Initial sizing and draw
            updateStagingUI();
            calculateRocketProperties(); // For initial empty state
            updateTelemetry(); // For initial empty state
            draw(); // Initial draw for build mode
        }

        init();
    </script>
</body>
</html>
