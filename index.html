<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Hide & Collect - Panic Mode</title>
    <style>
        /* ... (CSS mostly the same as previous Dyna-Q version) ... */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            padding: 5px;
            overscroll-behavior: none;
        }
        .controls {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 5px;
            background-color: #2a2a2a;
            border-radius: 5px;
            width: calc(100% - 10px);
            max-width: 780px;
            box-sizing: border-box;
        }
        .controls div { display: flex; flex-direction: column; align-items: center; }
        .controls label { font-size: 0.8em; margin-bottom: 2px; }
        .controls input[type="range"] { width: 100px; }
        .controls span { font-size: 0.8em; }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 400px;
        }
        canvas {
            border: 1px solid #444;
            background-color: #282828;
            max-width: 100%;
            height: auto;
            display: block;
        }
        #gameCanvas { background-color: #304050; }
        #aiVisionCanvas { background-color: #333; }
        .stats {
            border: 1px solid #444;
            padding: 8px;
            background-color: #2f2f2f;
            width: calc(100% - 18px);
            max-width: 380px;
            box-sizing: border-box;
        }
        .stats p { margin: 4px 0; font-size: 0.8em; }
        h1, h2 { text-align: center; margin-top: 5px; margin-bottom: 8px; }
        h1 {font-size: 1.5em;}
        h2 { font-size: 1.0em; }
         #panicStatus { font-weight: bold; color: orange; }


        @media (min-width: 768px) {
            .container {
                flex-direction: row;
                align-items: flex-start;
                max-width: 800px;
            }
            .game-area { flex: 2; }
            .ai-info { flex: 1; }
            .stats { width: auto; max-width: none; }
            .controls input[type="range"] { width: 120px; }
        }
    </style>
</head>
<body>
    <h1>AI Hide & Collect (Panic Mode)</h1>

    <div class="controls">
        <div>
            <label for="speedControl">Sim Speed (ms):</label>
            <input type="range" id="speedControl" min="10" max="500" value="50">
            <span id="speedValue">50</span>
        </div>
        <div>
            <label for="planningStepsControl">Planning Steps (k):</label>
            <input type="range" id="planningStepsControl" min="0" max="50" value="10">
            <span id="planningStepsValue">10</span>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
            <h2>Game World (<span id="panicStatus">NORMAL</span>)</h2>
            <canvas id="gameCanvas" width="300" height="450"></canvas>
        </div>
        <div class="ai-info">
            <h2>AI "Vision" & Model</h2>
            <canvas id="aiVisionCanvas" width="150" height="150"></canvas>
            <div class="stats">
                <h2>Stats</h2>
                <p>Episode: <span id="episode">0</span></p>
                <p>Cookies: <span id="cookies">0</span></p>
                <p>Punishments: <span id="punishments">0</span></p>
                <p>Epsilon: <span id="epsilon">1.000</span></p>
                <p>Last Action: <span id="lastAction">-</span></p>
                <p>Q-Table Size: <span id="qTableSize">0</span></p>
                <p>Env. Model Size: <span id="modelSize">0</span></p>
                <p>Total Steps: <span id="totalSteps">0</span></p>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const aiVisionCanvas = document.getElementById('aiVisionCanvas');
        const aiVisionCtx = aiVisionCanvas.getContext('2d');
        const panicStatusEl = document.getElementById('panicStatus');

        const episodeEl = document.getElementById('episode');
        // ... (other stat elements same as before)
        const cookiesEl = document.getElementById('cookies');
        const punishmentsEl = document.getElementById('punishments');
        const epsilonEl = document.getElementById('epsilon');
        const lastActionEl = document.getElementById('lastAction');
        const qTableSizeEl = document.getElementById('qTableSize');
        const modelSizeEl = document.getElementById('modelSize');
        const totalStepsEl = document.getElementById('totalSteps');


        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const planningStepsControl = document.getElementById('planningStepsControl');
        const planningStepsValue = document.getElementById('planningStepsValue');

        // --- Game Constants ---
        const PLAYER_SIZE = 15;
        const HUNTER_SIZE = 15;
        const COIN_RADIUS = 7;
        const PLAYER_NORMAL_SPEED = PLAYER_SIZE;       // Player's normal speed
        const PLAYER_PANIC_SPEED = PLAYER_SIZE * 1.5;  // Player's speed in panic mode (50% faster)
        const HUNTER_SPEED = PLAYER_SIZE;              // Hunter's speed (constant)
        let MAX_STEPS_PER_EPISODE = 350;

        // --- Game Objects & State ---
        let player = { 
            x: 50, y: 50, 
            width: PLAYER_SIZE, height: PLAYER_SIZE, 
            color: 'blue', 
            inPanic: false // New flag for panic mode
        };
        let hunter = { x: gameCanvas.width - 50, y: gameCanvas.height - 50, width: HUNTER_SIZE, height: HUNTER_SIZE, color: 'red' };
        let coins = [];
        let obstacles = [ /* ... (same obstacles as before) ... */ 
            { x: 100, y: 0, width: 20, height: 120, color: '#555' },
            { x: 100, y: gameCanvas.height - 120, width: 20, height: 120, color: '#555' },
            { x: 180, y: 200, width: 100, height: 20, color: '#555' },
            { x: 0, y: gameCanvas.height/2 - 10, width: 70, height: 20, color: '#555' },
            { x: gameCanvas.width-70, y: gameCanvas.height/2 - 50, width: 70, height: 20, color: '#555' },
            { x: 50, y: 50, width: 20, height: 80, color: '#555' },
            { x: gameCanvas.width - 70, y: gameCanvas.height - 130, width: 20, height: 80, color: '#555' }
        ];

        // --- AI Q-Learning & Dyna-Q Parameters ---
        // ... (AI parameters largely the same as Dyna-Q version)
        let qTable = {};
        let envModel = {}; 
        let observedStateActions = []; 

        const LEARNING_RATE = 0.1;
        const DISCOUNT_FACTOR = 0.9;
        let epsilon = 1.0;
        const EPSILON_DECAY = 0.9998; 
        const MIN_EPSILON = 0.05;    
        let numPlanningSteps = 10;    

        const ACTIONS = [
            { dx: 0, dy: -1, name: "Up" },
            { dx: 0, dy: 1, name: "Down" },
            { dx: -1, dy: 0, name: "Left" },
            { dx: 1, dy: 0, name: "Right" },
            { dx: 0, dy: 0, name: "Stay" }
        ];

        let scoreCookies = 0;
        let scorePunishments = 0;
        let episodeCount = 0;
        let currentStepsInEpisode = 0;
        let cumulativeTotalSteps = 0;

        let simIntervalId = null;
        let currentSimSpeed = 50;
        
        // --- Helper Functions (Collision, Spawning - mostly unchanged) ---
        function rectCollision(rect1, rect2) { /* ... */ return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }
        function spawnCoin() { /* ... (same as previous) ... */
            let coinX, coinY, validPosition;
            const maxAttempts = 50;
            let attempts = 0;
            do {
                validPosition = true;
                attempts++;
                coinX = COIN_RADIUS + Math.random() * (gameCanvas.width - 2 * COIN_RADIUS);
                coinY = COIN_RADIUS + Math.random() * (gameCanvas.height - 2 * COIN_RADIUS);

                for (const obs of obstacles) { 
                    const obsCenterX = obs.x + obs.width / 2;
                    const obsCenterY = obs.y + obs.height / 2;
                    const distToObsCenter = Math.hypot(coinX - obsCenterX, coinY - obsCenterY);
                    if (distToObsCenter < COIN_RADIUS + Math.max(obs.width, obs.height) / 2) {
                        if (coinX > obs.x && coinX < obs.x + obs.width && coinY > obs.y && coinY < obs.y + obs.height) {
                            validPosition = false; break;
                        }
                    }
                }
                if (!validPosition) continue;
                if (Math.hypot(coinX - (player.x+player.width/2), coinY - (player.y+player.height/2)) < PLAYER_SIZE * 3 + COIN_RADIUS) validPosition = false;
                if (Math.hypot(coinX - (hunter.x+hunter.width/2), coinY - (hunter.y+hunter.height/2)) < HUNTER_SIZE * 3 + COIN_RADIUS) validPosition = false;

            } while (!validPosition && attempts < maxAttempts);

            if (!validPosition) { 
                coinX = gameCanvas.width * Math.random(); 
                coinY = gameCanvas.height * Math.random();
            }
            coins = [{ x: coinX, y: coinY, radius: COIN_RADIUS, color: 'lime' }];
        }


        // --- State Discretization (mostly same, but now determines panic) ---
        function getAngleCategory(dx, dy) { /* ... */ return Math.floor((Math.atan2(dy, dx) + Math.PI) / (Math.PI / 4)) % 8; }
        function getDistanceCategory(dist, entitySize) { /* ... */ 
            if (dist < entitySize * 2) return 0; // Very Close
            if (dist < entitySize * 4) return 1; // Close (Adjusted threshold for panic)
            if (dist < entitySize * 10) return 2; // Medium
            return 3; // Far
        }
        function probeClearSteps(entity, unitDirX, unitDirY, maxProbeSteps, currentMoveSpeed) {
            let clearSteps = 0;
            for (let i = 1; i <= maxProbeSteps; i++) {
                const nextX = entity.x + unitDirX * i * currentMoveSpeed; // Use currentMoveSpeed
                const nextY = entity.y + unitDirY * i * currentMoveSpeed; // Use currentMoveSpeed
                const probeRect = { x: nextX, y: nextY, width: entity.width, height: entity.height };

                if (probeRect.x < 0 || probeRect.x + probeRect.width > gameCanvas.width ||
                    probeRect.y < 0 || probeRect.y + probeRect.height > gameCanvas.height) break;
                
                if (obstacles.some(obs => rectCollision(probeRect, obs))) break;
                clearSteps++;
            }
            if (clearSteps === 0) return 0;
            if (clearSteps === 1) return 1;
            return 2;
        }
        function isPathClear(entity1, entity2, obstaclesArr, checkWidth, checkHeight) { /* ... (same) ... */
            const e1cx = entity1.x + entity1.width / 2;
            const e1cy = entity1.y + entity1.height / 2;
            const e2Obj = (entity2.radius) ? { x: entity2.x, y: entity2.y, width: entity2.radius*2, height: entity2.radius*2 } : entity2; // Handle coin
            const e2cx = e2Obj.x + e2Obj.width / 2;
            const e2cy = e2Obj.y + e2Obj.height / 2;

            const dx = e2cx - e1cx;
            const dy = e2cy - e1cy;
            const dist = Math.hypot(dx, dy);

            if (dist < PLAYER_SIZE/4) return true; 
            const numSamples = Math.max(2, Math.ceil(dist / (PLAYER_SIZE / 3)));

            for (let i = 0; i <= numSamples; i++) {
                const t = i / numSamples;
                const currentX = e1cx + t * dx;
                const currentY = e1cy + t * dy;
                const probeRect = { x: currentX - checkWidth / 2, y: currentY - checkHeight / 2, width: checkWidth, height: checkHeight };
                if (obstaclesArr.some(obs => rectCollision(probeRect, obs))) return false;
            }
            return true;
        }

        function getDiscretizedState() {
            const relHx_center = (hunter.x + hunter.width/2) - (player.x + player.width/2);
            const relHy_center = (hunter.y + hunter.height/2) - (player.y + player.height/2);
            const hunterDistToPlayer = Math.hypot(relHx_center, relHy_center);
            const hunterAngle = getAngleCategory(relHx_center, relHy_center);
            const hunterDistCategory = getDistanceCategory(hunterDistToPlayer, PLAYER_SIZE); // Use PLAYER_SIZE as ref

            // Determine Panic State
            const hunterHasClearLOS = isPathClear(hunter, player, obstacles, hunter.width, hunter.height);
            if (hunterDistCategory === 0 && hunterHasClearLOS) { // Hunter very close AND visible
                player.inPanic = true;
            } else {
                player.inPanic = false;
            }
            panicStatusEl.textContent = player.inPanic ? "PANIC!" : "NORMAL";
            panicStatusEl.style.color = player.inPanic ? "red" : "lime";


            let coinAngle = 0, coinDistCategory = 3; 
            if (coins.length > 0) {
                const coin = coins[0];
                const relCx_center = coin.x - (player.x + player.width/2);
                const relCy_center = coin.y - (player.y + player.height/2);
                coinAngle = getAngleCategory(relCx_center, relCy_center);
                coinDistCategory = getDistanceCategory(Math.hypot(relCx_center, relCy_center), PLAYER_SIZE);
            }
            
            // Probe clear steps based on current player speed (normal or panic)
            const currentMoveSpeedForProbe = player.inPanic ? PLAYER_PANIC_SPEED : PLAYER_NORMAL_SPEED;
            const maxClearProbe = 2;
            const clearN = probeClearSteps(player, 0, -1, maxClearProbe, currentMoveSpeedForProbe);
            const clearS = probeClearSteps(player, 0, 1, maxClearProbe, currentMoveSpeedForProbe);
            const clearE = probeClearSteps(player, 1, 0, maxClearProbe, currentMoveSpeedForProbe);
            const clearW = probeClearSteps(player, -1, 0, maxClearProbe, currentMoveSpeedForProbe);

            const coinPathClear = (coins.length > 0) ? (isPathClear(player, coins[0], obstacles, player.width, player.height) ? 0 : 1) : 1;
            const hunterVisibleToPlayer = isPathClear(player, hunter, obstacles, player.width, player.height) ? 0 : 1; // Player's LoS to Hunter
            
            // Optional: Add player.inPanic to the state string if you want AI to learn distinct policies
            // return `${hunterAngle}_${hunterDistCategory}_${coinAngle}_${coinDistCategory}_${clearN}_${clearS}_${clearE}_${clearW}_${coinPathClear}_${hunterVisibleToPlayer}_${player.inPanic ? 1:0}`;
            return `${hunterAngle}_${hunterDistCategory}_${coinAngle}_${coinDistCategory}_${clearN}_${clearS}_${clearE}_${clearW}_${coinPathClear}_${hunterVisibleToPlayer}`;
        }

        // --- Q-Learning & Model Functions (same as Dyna-Q) ---
        function ensureQValue(state, actionIndex = -1) { /* ... */ if (!qTable[state]) { qTable[state] = Array(ACTIONS.length).fill(0); qTableSizeEl.textContent = Object.keys(qTable).length; } }
        function chooseAction(state) { /* ... */ ensureQValue(state); if (Math.random() < epsilon) { return Math.floor(Math.random() * ACTIONS.length); } else { const qV = qTable[state]; const mQ = Math.max(...qV); const bA = qV.reduce((a, q, i) => (q === mQ ? a.concat(i) : a), []); return bA[Math.floor(Math.random() * bA.length)]; } }
        function updateQTable(state, action, reward, nextState, isTerminal = false) { /* ... */ ensureQValue(state, action); ensureQValue(nextState); const oQ = qTable[state][action]; let mFQ = 0; if (!isTerminal) { mFQ = qTable[nextState] && qTable[nextState].length > 0 ? Math.max(...qTable[nextState]) : 0;} qTable[state][action] = oQ + LEARNING_RATE * (reward + DISCOUNT_FACTOR * mFQ - oQ); }
        function updateModel(state, action, reward, nextState) { /* ... */ if (!envModel[state]) { envModel[state] = {}; modelSizeEl.textContent = Object.keys(envModel).length;} if (!envModel[state][action]) { envModel[state][action] = { next_state_counts: {}, total_reward: 0, experience_count: 0}; observedStateActions.push({s: state, a: action});} const mE = envModel[state][action]; mE.total_reward += reward; mE.experience_count++; mE.next_state_counts[nextState] = (mE.next_state_counts[nextState] || 0) + 1; }
        function planningStep() { /* ... */ if (observedStateActions.length === 0) return; const rI = Math.floor(Math.random() * observedStateActions.length); const { s: s_m, a: a_m } = observedStateActions[rI]; const mE = envModel[s_m]?.[a_m]; if (!mE || mE.experience_count === 0) return; const r_m = mE.total_reward / mE.experience_count; let s_p_m = null; let mC = 0; for (const [n_s, c] of Object.entries(mE.next_state_counts)) { if (c > mC) { mC = c; s_p_m = n_s; } } if (s_p_m === null) return; updateQTable(s_m, a_m, r_m, s_p_m, false); }

        // --- Game Logic ---
        function resetGame() { /* ... (same as Dyna-Q) ... */
            player.inPanic = false; // Reset panic state
            panicStatusEl.textContent = "NORMAL";
            panicStatusEl.style.color = "lime";
             let attempts = 0; const maxSpawnAttempts = 30;
            do { player.x = PLAYER_SIZE + Math.random() * (gameCanvas.width - 3 * PLAYER_SIZE); player.y = PLAYER_SIZE + Math.random() * (gameCanvas.height - 3 * PLAYER_SIZE); attempts++; } while (obstacles.some(obs => rectCollision(player, obs)) && attempts < maxSpawnAttempts);
            attempts = 0;
            do { hunter.x = PLAYER_SIZE + Math.random() * (gameCanvas.width - 3 * PLAYER_SIZE); hunter.y = PLAYER_SIZE + Math.random() * (gameCanvas.height - 3 * PLAYER_SIZE); attempts++; } while ((obstacles.some(obs => rectCollision(hunter, obs)) || Math.hypot(player.x-hunter.x, player.y-hunter.y) < gameCanvas.width/2.5) && attempts < maxSpawnAttempts);
            spawnCoin(); currentStepsInEpisode = 0; episodeCount++;
            episodeEl.textContent = episodeCount; cookiesEl.textContent = scoreCookies; punishmentsEl.textContent = scorePunishments;
            if (epsilon > MIN_EPSILON) epsilon *= EPSILON_DECAY;
            epsilonEl.textContent = epsilon.toFixed(3);
        }

        function moveEntity(entity, dxMultiplier, dyMultiplier, customSpeed = -1) {
            const currentMoveSpeed = (customSpeed !== -1) ? customSpeed : (entity === player ? (player.inPanic ? PLAYER_PANIC_SPEED : PLAYER_NORMAL_SPEED) : HUNTER_SPEED);
            
            const moveAmountX = dxMultiplier * currentMoveSpeed;
            const moveAmountY = dyMultiplier * currentMoveSpeed;

            const oldX = entity.x;
            const oldY = entity.y;
            let newX = entity.x + moveAmountX;
            let newY = entity.y + moveAmountY;

            if (newX < 0) newX = 0;
            if (newX + entity.width > gameCanvas.width) newX = gameCanvas.width - entity.width;
            if (newY < 0) newY = 0;
            if (newY + entity.height > gameCanvas.height) newY = gameCanvas.height - entity.height;
            
            let finalX = oldX;
            let finalY = oldY;

            let tempEntityX = { ...entity, x: newX, y: oldY };
            let collisionX = obstacles.some(obs => rectCollision(tempEntityX, obs));
            if (!collisionX) finalX = newX;

            let tempEntityY = { ...entity, x: oldX, y: newY }; 
            let collisionY = obstacles.some(obs => rectCollision(tempEntityY, obs));
            if (!collisionY) finalY = newY;
            
            if (dxMultiplier !== 0 && dyMultiplier !== 0 && !collisionX && !collisionY) {
                let tempEntityXY = { ...entity, x: newX, y: newY };
                if (!obstacles.some(obs => rectCollision(tempEntityXY, obs))) {
                    finalX = newX;
                    finalY = newY;
                }
            }
            
            entity.x = finalX;
            entity.y = finalY;
            return (finalX === oldX && finalY === oldY && (dxMultiplier !==0 || dyMultiplier !==0) );
        }

        function updateGame(actionIndex) {
            const action = ACTIONS[actionIndex];
            lastActionEl.textContent = action.name;
            let reward = -0.02;

            // Player movement uses its current speed (normal or panic)
            const playerStuck = moveEntity(player, action.dx, action.dy); // moveEntity now handles player's dynamic speed
            if (playerStuck) reward -= 0.2;

            // Hunter movement (constant speed)
            const hunterTargetX = player.x + player.width / 2;
            const hunterTargetY = player.y + player.height / 2;
            const hunterCurrentX = hunter.x + hunter.width / 2;
            const hunterCurrentY = hunter.y + hunter.height / 2;
            let hdx = 0, hdy = 0;
            if (Math.abs(hunterTargetX - hunterCurrentX) > HUNTER_SPEED / 3) hdx = Math.sign(hunterTargetX - hunterCurrentX);
            if (Math.abs(hunterTargetY - hunterCurrentY) > HUNTER_SPEED / 3) hdy = Math.sign(hunterTargetY - hunterCurrentY);
            moveEntity(hunter, hdx, hdy, HUNTER_SPEED); // Explicitly pass HUNTER_SPEED

            // ... (rest of updateGame: collision checks, rewards, step counts - same as Dyna-Q)
            if (rectCollision(player, hunter)) { reward -= 20; scorePunishments++; return { reward, done: true }; }
            if (coins.length > 0) { const coin = coins[0]; if (Math.hypot((player.x + player.width/2) - coin.x, (player.y + player.height/2) - coin.y) < player.width/2 + coin.radius) { reward += 20; scoreCookies++; coins.splice(0, 1); spawnCoin(); return { reward, done: true }; } }
            currentStepsInEpisode++; cumulativeTotalSteps++; totalStepsEl.textContent = cumulativeTotalSteps;
            if (currentStepsInEpisode >= MAX_STEPS_PER_EPISODE) { reward -= 10; scorePunishments++; return { reward, done: true }; }
            return { reward, done: false };
        }

        // --- Drawing Functions (same as Dyna-Q, player color could change in panic) ---
        function drawGame() {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            obstacles.forEach(obs => { gameCtx.fillStyle = obs.color; gameCtx.fillRect(obs.x, obs.y, obs.width, obs.height); });
            coins.forEach(coin => { gameCtx.beginPath(); gameCtx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2); gameCtx.fillStyle = coin.color; gameCtx.fill(); });
            
            // Change player color in panic mode
            gameCtx.fillStyle = player.inPanic ? 'orange' : player.color;
            gameCtx.fillRect(player.x, player.y, player.width, player.height);
            
            gameCtx.fillStyle = hunter.color; 
            gameCtx.fillRect(hunter.x, hunter.y, hunter.width, hunter.height);
        }
        function drawAiVision() { /* ... (same as Dyna-Q) ... */
             aiVisionCtx.clearRect(0, 0, aiVisionCanvas.width, aiVisionCanvas.height);
            const stateStr = getDiscretizedState(); // Call this to ensure player.inPanic is updated for vision
            const parts = stateStr.split('_');
            
            aiVisionCtx.fillStyle = '#ddd'; 
            aiVisionCtx.font = '10px monospace';
            let yPos = 12;
            const lineHeight = 11;

            if (parts.length >= 10) { // Adjusted for if panic was added to state string
                 aiVisionCtx.fillText(`H:${parts[0]}A ${parts[1]}D C:${parts[2]}A ${parts[3]}D`, 3, yPos); yPos += lineHeight;
                 aiVisionCtx.fillText(`PthC:${parts[8]==='0'?'CLR':'BLK'} VisH:${parts[9]==='0'?'VIS':'HID'}`, 3, yPos); yPos += lineHeight;
                 aiVisionCtx.fillText(`StN:${parts[4]} S:${parts[5]} E:${parts[6]} W:${parts[7]}`, 3, yPos); yPos += lineHeight;
                 // if (parts.length === 11) aiVisionCtx.fillText(`Panic: ${parts[10]==='1'?'YES':'NO'}`, 3, yPos); yPos+= lineHeight;
            } else {
                 aiVisionCtx.fillText(stateStr.substring(0, 25), 3, yPos);  yPos += lineHeight; 
                 if(stateStr.length > 25) aiVisionCtx.fillText(stateStr.substring(25), 3, yPos); yPos += lineHeight;
            }
             aiVisionCtx.fillText(`Mode: ${player.inPanic ? "PANIC" : "Normal"}`, 3, yPos); yPos += lineHeight;


            const mapScale = 0.2; 
            const mapOffsetX = aiVisionCanvas.width / 2 - (gameCanvas.width * mapScale / 2);
            const mapOffsetY = yPos + 2;

            aiVisionCtx.save();
            aiVisionCtx.translate(mapOffsetX, mapOffsetY);
            aiVisionCtx.scale(mapScale, mapScale);
            aiVisionCtx.globalAlpha = 0.7;
            aiVisionCtx.fillStyle = '#666'; 
            obstacles.forEach(obs => aiVisionCtx.fillRect(obs.x, obs.y, obs.width, obs.height));
            if (coins.length > 0) { aiVisionCtx.beginPath(); aiVisionCtx.arc(coins[0].x, coins[0].y, coins[0].radius / mapScale * 0.6 , 0, Math.PI * 2); aiVisionCtx.fillStyle = coins[0].color; aiVisionCtx.fill(); }
            aiVisionCtx.fillStyle = hunter.color; aiVisionCtx.fillRect(hunter.x, hunter.y, hunter.width, hunter.height);
            aiVisionCtx.fillStyle = player.inPanic ? 'orange' : player.color; aiVisionCtx.fillRect(player.x, player.y, player.width, player.height);
            aiVisionCtx.globalAlpha = 1.0;
            aiVisionCtx.restore();
        }

        // --- Main AI Loop (same structure as Dyna-Q) ---
        function aiLoop() {
            const currentState = getDiscretizedState(); // This will also update player.inPanic
            const actionToTake = chooseAction(currentState);
            const gameOutcome = updateGame(actionToTake);
            const nextStateAfterAction = getDiscretizedState();
            updateQTable(currentState, actionToTake, gameOutcome.reward, nextStateAfterAction, gameOutcome.done);
            updateModel(currentState, actionToTake, gameOutcome.reward, nextStateAfterAction);
            for (let i = 0; i < numPlanningSteps; i++) planningStep();
            drawGame();
            drawAiVision();
            if (gameOutcome.done) resetGame();
        }

        // --- Initialize and Start (same as Dyna-Q) ---
        function init() {
            currentSimSpeed = parseInt(speedControl.value); speedValue.textContent = currentSimSpeed;
            numPlanningSteps = parseInt(planningStepsControl.value); planningStepsValue.textContent = numPlanningSteps;
            speedControl.addEventListener('input', (e) => { currentSimSpeed = parseInt(e.target.value); speedValue.textContent = currentSimSpeed; if (simIntervalId) clearInterval(simIntervalId); simIntervalId = setInterval(aiLoop, currentSimSpeed); });
            planningStepsControl.addEventListener('input', (e) => { numPlanningSteps = parseInt(e.target.value); planningStepsValue.textContent = numPlanningSteps; });
            resetGame(); drawGame(); drawAiVision();
            if (simIntervalId) clearInterval(simIntervalId);
            simIntervalId = setInterval(aiLoop, currentSimSpeed);
        }
        window.onload = init;
    </script>
</body>
</html>
