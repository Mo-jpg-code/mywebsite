<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Satellite Tracker</title>
    <style>
        :root {
            --primary-bg: #0a0a1a; --panel-bg: rgba(25, 25, 50, 0.92); --text-color: #e0e0e0;
            --accent-color: #3498db; --highlight-color: #58a6ff; --border-color: rgba(255, 255, 255, 0.15);
            --button-bg: rgba(52, 152, 219, 0.6); --button-hover-bg: rgba(52, 152, 219, 0.9);
            --danger-color: rgba(231, 76, 60, 0.8);
        }
        body {
            margin: 0; overflow: hidden; background-color: var(--primary-bg); color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            overscroll-behavior: none; position: fixed; width: 100%; height: 100%;
        }
        #app-container { width: 100%; height: 100%; position: relative; }
        #renderer-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--primary-bg);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10000;
            transition: opacity 0.5s ease-out;
        }
        #loading-spinner {
            border: 6px solid #333; border-top: 6px solid var(--accent-color); border-radius: 50%;
            width: 50px; height: 50px; animation: spin 1s linear infinite;
        }
        #loading-text { margin-top: 20px; font-size: 1.1em; color: #aaa; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .overlay-panel {
            position: fixed; background-color: var(--panel-bg); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border-top: 1px solid var(--border-color); box-shadow: 0 -5px 20px rgba(0,0,0,0.3); color: var(--text-color);
            z-index: 100; transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1); overflow-y: auto;
            display: flex; flex-direction: column;
        }
        .panel-header {
            padding: 12px 15px; font-size: 1.2em; color: var(--highlight-color); border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
        }
        .panel-header .close-btn {
            background: none; border: none; color: var(--text-color); font-size: 1.8em;
            padding: 5px; line-height: 1; cursor: pointer;
        }
        .panel-content { padding: 15px; flex-grow: 1; overflow-y: auto; }
        #info-panel {
            bottom: 0; left: 0; right: 0; max-height: 65vh; transform: translateY(100%);
            border-top-left-radius: 12px; border-top-right-radius: 12px;
        }
        #info-panel.visible { transform: translateY(0); }
        #info-panel p { margin: 6px 0; font-size: 0.9em; line-height: 1.5; }
        #info-panel strong { color: #a0c8ff; }
        #follow-satellite-toggle {
            background-color: var(--button-bg); color: white; border: none; padding: 12px 15px;
            border-radius: 8px; cursor: pointer; margin-top: 15px; transition: background-color 0.2s;
            display: block; width: 100%; font-size: 0.95em;
        }
        #follow-satellite-toggle:hover, #follow-satellite-toggle:active { background-color: var(--button-hover-bg); }
        #follow-satellite-toggle.following { background-color: var(--danger-color); }
        #filter-panel {
            top: 0; bottom: 0; right: 0; width: 85vw; max-width: 320px; transform: translateX(100%);
            border-top: none; border-left: 1px solid var(--border-color); box-shadow: -5px 0 20px rgba(0,0,0,0.3);
            border-top-left-radius: 12px; border-bottom-left-radius: 12px;
        }
        #filter-panel.visible { transform: translateX(0); }
        .filter-group { margin-bottom: 18px; }
        .filter-group label { display: block; margin-bottom: 6px; font-size: 0.9em; color: #aabbcc; }
        .filter-group select, .filter-group input[type="number"] {
            width: 100%; padding: 10px; border-radius: 6px; box-sizing: border-box;
            border: 1px solid rgba(255,255,255,0.2); background-color: rgba(10,10,20,0.8);
            color: var(--text-color); font-size: 0.9em;
        }
        .year-filter-inputs { display: flex; gap: 10px; }
        .filter-buttons button {
            background: var(--button-bg); border: none; color: white; padding: 12px 15px; margin-top: 10px;
            border-radius: 8px; cursor: pointer; transition: background-color 0.2s; font-size: 0.95em; width: calc(50% - 5px);
        }
        .filter-buttons button:hover, .filter-buttons button:active { background: var(--button-hover-bg); }
        .filter-buttons button.clear { background: rgba(200, 80, 80, 0.7); }
        #visible-sat-count-container { font-size:0.85em; color:#8899aa; margin-top:15px; text-align: center; }
        #search-overlay {
            top: 0; left: 0; right: 0; bottom: 0; transform: translateY(-100%); border-top: none;
            box-shadow: none; border-radius: 0; display: flex; flex-direction: column;
        }
        #search-overlay.visible { transform: translateY(0); }
        #search-input-container {
            padding: 10px; background-color: rgba(10,10,20,0.7); flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
        }
        #search-input {
            width: 100%; padding: 12px 15px; border-radius: 25px; box-sizing: border-box;
            border: 1px solid rgba(255,255,255,0.2); background-color: rgba(30,30,60,0.8);
            color: var(--text-color); font-size: 1em; outline: none;
        }
        #search-results { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; }
        #search-results li {
            padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.08); cursor: pointer;
            transition: background-color 0.2s; font-size: 0.95em;
        }
        #search-results li:hover, #search-results li:active { background-color: rgba(52, 152, 219, 0.2); }
        #search-results li:last-child { border-bottom: none; }
        #timeline-container {
            position: fixed; bottom: 60px; left: 10px; right: 10px; background-color: var(--panel-bg);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid var(--border-color);
            border-radius: 10px; padding: 8px 12px; z-index: 90; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; align-items: center;
        }
        #timeline-slider { width: 100%; cursor: pointer; margin: 5px 0; }
        #time-display { font-size: 0.75em; color: #ccc; margin-bottom: 5px; }
        #time-controls button {
            background: var(--button-bg); border: none; color: white; padding: 6px 10px; margin: 0 3px;
            border-radius: 6px; cursor: pointer; font-size: 0.8em; min-width: 36px;
        }
        #time-controls { display: flex; justify-content: center; width: 100%;}
        #time-speed { font-size: 0.8em; color: #ccc; margin-left: 8px;}
        #main-controls-bar {
            position: fixed; bottom: 0; left: 0; right: 0; height: 50px; background-color: var(--primary-bg);
            border-top: 1px solid var(--border-color); display: flex; justify-content: space-around;
            align-items: center; z-index: 200; padding: 0 10px;
        }
        .control-button {
            background: none; border: none; color: var(--text-color); font-size: 1.6em;
            padding: 10px 15px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s;
        }
        .control-button:hover, .control-button:active { opacity: 1; color: var(--highlight-color); }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: rgba(52, 152, 219, 0.4); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(52, 152, 219, 0.7); }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="renderer-container"></div>
        <div id="loading-screen">
            <div id="loading-spinner"></div>
            <div id="loading-text">Initializing Celestial Sphere...</div>
        </div>
        <div id="info-panel" class="overlay-panel">
            <div class="panel-header">
                <span id="sat-name-header">Satellite Info</span>
                <button class="close-btn" onclick="hideInfoPanel()">×</button>
            </div>
            <div class="panel-content">
                <p><strong>Name:</strong> <span id="sat-name"></span></p>
                <p><strong>NORAD ID:</strong> <span id="sat-norad-id"></span></p>
                <p><strong>Int'l Des:</strong> <span id="sat-intl-des"></span></p>
                <p><strong>Launch:</strong> <span id="sat-launch-date"></span> (<span id="sat-launch-year"></span>)</p>
                <p><strong>Country:</strong> <span id="sat-country"></span></p>
                <p><strong>Orbit:</strong> <span id="sat-orbit-type"></span></p>
                <p><strong>Constellation:</strong> <span id="sat-constellation"></span></p>
                <p><strong>Altitude:</strong> <span id="sat-altitude"></span> km</p>
                <p><strong>Velocity:</strong> <span id="sat-velocity"></span> km/s</p>
                <p><strong>Period:</strong> <span id="sat-period"></span> min</p>
                <p><strong>Inclination:</strong> <span id="sat-inclination"></span>°</p>
                <p><strong>Lat/Lon:</strong> <span id="sat-lat"></span>° / <span id="sat-lon"></span>°</p>
                <button id="follow-satellite-toggle" onclick="toggleFollowSatellite()">Follow Satellite</button>
            </div>
        </div>
        <div id="filter-panel" class="overlay-panel">
            <div class="panel-header">
                <span>Filters</span>
                <button class="close-btn" onclick="toggleFilterPanel(false)">×</button>
            </div>
            <div class="panel-content">
                <div class="filter-group">
                    <label for="filter-launch-year-min">Launch Year:</label>
                    <div class="year-filter-inputs">
                        <input type="number" id="filter-launch-year-min" min="1957" placeholder="Min">
                        <input type="number" id="filter-launch-year-max" min="1957" placeholder="Max">
                    </div>
                </div>
                <div class="filter-group">
                    <label for="filter-country">Country:</label>
                    <select id="filter-country"><option value="">All</option></select>
                </div>
                <div class="filter-group">
                    <label for="filter-orbit-type">Orbit Type:</label>
                    <select id="filter-orbit-type">
                        <option value="">All</option> <option value="LEO">LEO</option> <option value="MEO">MEO</option>
                        <option value="GEO">GEO</option> <option value="HEO">HEO</option> <option value="Other">Other</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="filter-constellation">Constellation:</label>
                    <select id="filter-constellation"><option value="">All</option></select>
                </div>
                <div class="filter-buttons">
                    <button id="apply-filters-btn">Apply</button>
                    <button id="clear-filters-btn" class="clear">Clear</button>
                </div>
                 <p id="visible-sat-count-container">Visible: <span id="visible-sat-count">N/A</span></p>
            </div>
        </div>
        <div id="search-overlay" class="overlay-panel">
             <div class="panel-header">
                <span>Search Satellites</span>
                <button class="close-btn" onclick="toggleSearchOverlay(false)">×</button>
            </div>
            <div id="search-input-container">
                <input type="text" id="search-input" placeholder="Search (e.g., ISS, Starlink)">
            </div>
            <ul id="search-results"></ul>
        </div>
        <div id="timeline-container">
            <div id="time-display">Sim Time: N/A</div>
            <input type="range" id="timeline-slider" min="0" max="1440" value="0" step="1">
            <div id="time-controls">
                <button id="time-rewind"><<</button>
                <button id="time-play-pause">Play</button>
                <button id="time-forward">>></button>
                <button id="time-reset">Reset</button>
                <span id="time-speed">1x</span>
            </div>
        </div>
        <div id="main-controls-bar">
            <button class="control-button" id="search-toggle-btn" title="Search"></button>
            <button class="control-button" id="filter-toggle-btn" title="Filter"></button>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.3/satellite.min.js"></script>
    <script>
        let scene, camera, renderer, earth, clouds, stars, controls;
        let clock = new THREE.Clock();
        let allSatellitesData = [];
        let satelliteObjects = new Map();
        const EARTH_RADIUS_KM = 6371;
        const MU_EARTH = 398600.4418;
        const SCALE_FACTOR = 1 / EARTH_RADIUS_KM;
        let targetSatelliteObject;
        let raycaster, pointer = new THREE.Vector2();
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');
        const rendererContainer = document.getElementById('renderer-container');
        const infoPanel = document.getElementById('info-panel');
        const filterPanel = document.getElementById('filter-panel');
        const searchOverlay = document.getElementById('search-overlay');
        const searchInput = document.getElementById('search-input');
        const searchResultsList = document.getElementById('search-results');
        const followSatelliteToggleBtn = document.getElementById('follow-satellite-toggle');
        let currentTime = new Date();
        let timeScale = 1;
        let timePaused = false;
        const timelineSlider = document.getElementById('timeline-slider');
        const timeDisplay = document.getElementById('time-display');
        const timePlayPauseBtn = document.getElementById('time-play-pause');
        const timeRewindBtn = document.getElementById('time-rewind');
        const timeForwardBtn = document.getElementById('time-forward');
        const timeResetBtn = document.getElementById('time-reset');
        const timeSpeedDisplay = document.getElementById('time-speed');
        let initialTime = new Date();
        let focusedSatellitePathLine = null;
        let isFollowingSatellite = false;
        let isCameraAnimating = false;
        let cameraFocusTargetPosition = new THREE.Vector3();
        let desiredCameraPosition = new THREE.Vector3();
        const currentYear = new Date().getFullYear();

        const orbitControlsScript = document.createElement('script');
        orbitControlsScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
        orbitControlsScript.onload = () => { initApp(); animateApp(); };
        document.head.appendChild(orbitControlsScript);

        function initApp() {
            setupThreeJS();
            loadSatellitesAndMetadata();
            setupUIEventListeners();
            setupTimeControls();
            updateTimeDisplay();
            document.getElementById('filter-launch-year-min').max = currentYear;
            document.getElementById('filter-launch-year-max').max = currentYear;
            document.getElementById('filter-launch-year-max').placeholder = currentYear;
            document.getElementById('filter-launch-year-min').value = 1957;
            document.getElementById('filter-launch-year-max').value = currentYear;
            window.addEventListener('resize', onWindowResize, false);
            rendererContainer.addEventListener('pointerdown', onPointerDown, false);
            hideLoadingScreen();
        }
        function hideLoadingScreen(){
            loadingScreen.style.opacity = '0';
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 500);
        }
        function setupThreeJS() {
            loadingText.innerText = "Setting up 3D scene...";
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.001, 1000);
            camera.position.z = 3.5;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            rendererContainer.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0x707090, 1.2); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 3, 5); scene.add(directionalLight);
            loadingText.innerText = "Loading Earth textures...";
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg');
            const earthSpecularMap = textureLoader.load('https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73776/world.topo.bathy.200412.3x1350x675.PPM');
            const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture, specularMap: earthSpecularMap, specular: new THREE.Color('grey')});
            const earthGeometry = new THREE.SphereGeometry(1, 48, 48);
            earth = new THREE.Mesh(earthGeometry, earthMaterial); scene.add(earth);
            const cloudTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_2048.png');
            const cloudMaterial = new THREE.MeshPhongMaterial({ map: cloudTexture, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
            const cloudGeometry = new THREE.SphereGeometry(1.008, 48, 48);
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial); scene.add(clouds);
            loadingText.innerText = "Generating starfield...";
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.006, sizeAttenuation: true });
            const starVertices = [];
            for (let i = 0; i < 8000; i++) {
                const r = Math.random() * 150 + 70; const phi = Math.random() * Math.PI * 2; const theta = Math.random() * Math.PI;
                starVertices.push(r * Math.sin(theta) * Math.cos(phi), r * Math.sin(theta) * Math.sin(phi), r * Math.cos(theta));
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.08;
            controls.minDistance = 1.15; controls.maxDistance = 80; controls.enablePan = true;
            raycaster = new THREE.Raycaster();
        }
        function setupUIEventListeners() {
            document.getElementById('search-toggle-btn').addEventListener('click', () => toggleSearchOverlay(true));
            document.getElementById('filter-toggle-btn').addEventListener('click', () => toggleFilterPanel(true));
            document.getElementById('apply-filters-btn').addEventListener('click', () => { applyFilters(); toggleFilterPanel(false); });
            document.getElementById('clear-filters-btn').addEventListener('click', clearFilters);
            searchInput.addEventListener('input', handleSearch);
            searchResultsList.addEventListener('click', handleSearchResultClick);
        }
        function toggleSearchOverlay(show) { searchOverlay.classList.toggle('visible', show); if(show) searchInput.focus(); }
        function toggleFilterPanel(show) { filterPanel.classList.toggle('visible', show); }
        function showInfoPanel() { infoPanel.classList.add('visible'); }
        function hideInfoPanel() { infoPanel.classList.remove('visible'); if (targetSatelliteObject) { deselectSatellite(); } }
        async function loadSatellitesAndMetadata() {
            loadingText.innerText = "Fetching satellite TLE data...";
            const uniqueCountries = new Set(); const uniqueConstellations = new Set();
            try {
                const proxyUrl = 'https://corsproxy.io/?';
                const tleUrl = 'https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle';
                let tleData;
                try {
                    const response = await fetch(tleUrl);
                    if (!response.ok) throw new Error(`Direct fetch failed: ${response.status}`);
                    tleData = await response.text();
                } catch (e) {
                    console.warn("Direct fetch failed, trying proxy...", e.message);
                    const proxyResponse = await fetch(proxyUrl + encodeURIComponent(tleUrl));
                    if(!proxyResponse.ok) throw new Error(`Proxy fetch failed: ${proxyResponse.status}`);
                    tleData = await proxyResponse.text();
                }
                loadingText.innerText = "Parsing TLE data & calculating metadata...";
                const tleLines = tleData.trim().split('\n');
                for (let i = 0; i < tleLines.length; i += 3) {
                    const name = tleLines[i].trim(); const tle1 = tleLines[i+1].trim(); const tle2 = tleLines[i+2].trim();
                    if (!name || !tle1 || !tle2) continue;
                    try {
                        const satrec = satellite.twoline2satrec(tle1, tle2);
                        const noradId = tle2.substring(2, 7).trim(); const intlDes = tle1.substring(9, 17).trim();
                        let launchYear = parseInt(intlDes.substring(0, 2)); launchYear += (launchYear < 57) ? 2000 : 1900;
                        const periodMinutes = (2 * Math.PI) / satrec.no;
                        const approxAltitudeKm = calculateAltitudeFromPeriod(periodMinutes);
                        const inclinationDeg = satellite.degrees(satrec.inclo);
                        let orbitType = 'Other';
                        if (approxAltitudeKm < 2000) orbitType = 'LEO';
                        else if (Math.abs(periodMinutes - 1436.07) < 30 && inclinationDeg < 15) orbitType = 'GEO';
                        else if (approxAltitudeKm >= 2000 && approxAltitudeKm < 35700) orbitType = 'MEO';
                        else if (satrec.ecco > 0.25) orbitType = 'HEO';
                        const country = getCountryFromIntlDes(intlDes, name); const constellation = inferConstellation(name);
                        uniqueCountries.add(country); uniqueConstellations.add(constellation);
                        allSatellitesData.push({ name, satrec, noradId, intlDes, launchDate: `${launchYear}-XX-XX`, launchYear, country, periodMinutes, approxAltitudeKm, inclinationDeg, orbitType, constellation });
                    } catch (e) { }
                }
                populateFilterDropdowns(uniqueCountries, uniqueConstellations);
                createSatelliteVisuals(allSatellitesData); applyFilters();
            } catch (error) { loadingText.innerText = "Error loading satellite data."; console.error("Error loading satellite data:", error); }
        }
        function calculateAltitudeFromPeriod(periodMinutes) {
            if (!periodMinutes || periodMinutes <= 0) return 0; const T_seconds = periodMinutes * 60;
            const a_cubed = (T_seconds * T_seconds * MU_EARTH) / (4 * Math.PI * Math.PI); const a = Math.cbrt(a_cubed);
            return a - EARTH_RADIUS_KM;
        }
        function inferConstellation(name) {
            const lowerName = name.toLowerCase();
            if (lowerName.includes('starlink')) return 'Starlink'; if (lowerName.includes('gps') || lowerName.includes('navstar')) return 'GPS';
            if (lowerName.includes('glonass')) return 'GLONASS'; if (lowerName.includes('galileo')) return 'Galileo';
            if (lowerName.includes('beidou') || lowerName.includes('compass')) return 'BeiDou'; if (lowerName.includes('iridium')) return 'Iridium';
            if (lowerName.includes('oneweb')) return 'OneWeb'; if (lowerName.includes('planet') || lowerName.includes('skysat') || lowerName.includes('dove')) return 'Planet Labs';
            return 'Other';
        }
        function getCountryFromIntlDes(intlDesFull, name) {
            const commonCountryCodes = { 'US': 'USA', 'SU': 'Russia (USSR)', 'F': 'France', 'CN': 'China', 'J': 'Japan', 'I': 'Italy', 'IN': 'India', 'CA': 'Canada', 'DE': 'Germany', 'UK': 'UK', 'ES': 'Spain', 'AR': 'Argentina', 'BR': 'Brazil', 'AU': 'Australia', 'KR': 'South Korea', 'IL': 'Israel', 'UAE': 'UAE', 'EU': 'ESA', 'AS': 'AsiaSat', 'SES': 'SES', 'INT': 'Intelsat', 'ITS': 'ITS', 'LU': 'Luxembourg' };
            const upperName = name ? name.toUpperCase() : "";
            for (const code in commonCountryCodes) { if (upperName.includes(code + "-") || upperName.includes(code + " ")) return commonCountryCodes[code]; }
            if (intlDesFull) { const parts = intlDesFull.split('-'); if (parts.length > 1) { const potentialCode = parts[parts.length-1].replace(/[A-Z]+$/, '').substring(0,2); if(commonCountryCodes[potentialCode]) return commonCountryCodes[potentialCode]; } }
            return "Unknown";
        }
        function populateFilterDropdowns(countries, constellations) {
            const countrySelect = document.getElementById('filter-country'); Array.from(countries).sort().forEach(c => { if(c !== "Unknown") countrySelect.add(new Option(c, c)); });
            const constellSelect = document.getElementById('filter-constellation'); Array.from(constellations).sort().forEach(c => { if(c !== "Other") constellSelect.add(new Option(c,c)); });
        }
        function createSatelliteVisuals(satsData) {
            loadingText.innerText = `Visualizing ${satsData.length} satellites...`;
            const satMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 }); const satSelectedMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const satGeometry = new THREE.SphereGeometry(0.004, 5, 5);
            satsData.forEach(satData => {
                const satMesh = new THREE.Mesh(satGeometry, satMaterial.clone());
                satMesh.userData = { ...satData, defaultMaterial: satMaterial, selectedMaterial: satSelectedMaterial };
                satMesh.visible = false; scene.add(satMesh); satelliteObjects.set(satData.noradId, satMesh);
            });
            updateSatellitePositions(true);
        }
        function applyFilters() {
            const minLaunchYear = parseInt(document.getElementById('filter-launch-year-min').value) || 1957;
            const maxLaunchYear = parseInt(document.getElementById('filter-launch-year-max').value) || currentYear;
            const countryFilter = document.getElementById('filter-country').value;
            const orbitTypeFilter = document.getElementById('filter-orbit-type').value;
            const constellationFilter = document.getElementById('filter-constellation').value;
            let visibleCount = 0;
            allSatellitesData.forEach(satData => {
                const satMesh = satelliteObjects.get(satData.noradId); if (!satMesh) return;
                let passesFilters = true;
                if (satData.launchYear < minLaunchYear || satData.launchYear > maxLaunchYear) passesFilters = false;
                if (countryFilter && satData.country !== countryFilter) passesFilters = false;
                if (orbitTypeFilter && satData.orbitType !== orbitTypeFilter) passesFilters = false;
                if (constellationFilter && satData.constellation !== constellationFilter) passesFilters = false;
                satMesh.visible = passesFilters; if (passesFilters) visibleCount++;
            });
            document.getElementById('visible-sat-count').textContent = `${visibleCount} / ${allSatellitesData.length}`;
            if (targetSatelliteObject && !targetSatelliteObject.visible) deselectSatellite();
        }
        function clearFilters() {
            document.getElementById('filter-launch-year-min').value = 1957; document.getElementById('filter-launch-year-max').value = currentYear;
            document.getElementById('filter-country').value = ""; document.getElementById('filter-orbit-type').value = "";
            document.getElementById('filter-constellation').value = ""; applyFilters();
        }
        function updateSatellitePositions(forceUpdateAll = false) {
            if (allSatellitesData.length === 0) return; if (timePaused && !forceUpdateAll) return;
            const gmst = satellite.gstime(currentTime);
            allSatellitesData.forEach(satData => {
                const satMesh = satelliteObjects.get(satData.noradId); if (!satMesh) return;
                const isCurrentlyTargeted = targetSatelliteObject && targetSatelliteObject.userData && targetSatelliteObject.userData.noradId === satData.noradId;
                if (!forceUpdateAll && !satMesh.visible && !isCurrentlyTargeted) return;
                try {
                    const positionAndVelocity = satellite.propagate(satData.satrec, currentTime);
                    if (!positionAndVelocity.position || !positionAndVelocity.velocity) return;
                    const pEci = positionAndVelocity.position; const vEci = positionAndVelocity.velocity;
                    const geodetic = satellite.eciToGeodetic(pEci, gmst);
                    satData.latitude = satellite.degreesLat(geodetic.latitude); satData.longitude = satellite.degreesLong(geodetic.longitude);
                    satData.altitude = geodetic.height; satData.velocity = Math.sqrt(vEci.x**2 + vEci.y**2 + vEci.z**2);
                    satMesh.position.set( pEci.x*SCALE_FACTOR, pEci.z*SCALE_FACTOR, -pEci.y*SCALE_FACTOR );
                    if (isCurrentlyTargeted && focusedSatellitePathLine) { drawOrbitPathForSatellite(satData); }
                } catch (e) { }
            });
            if (targetSatelliteObject) { updateLiveInfoPanel(targetSatelliteObject.userData); }
        }
        function setupTimeControls() {
            initialTime = new Date(currentTime); timelineSlider.max = 24 * 60;
            timelineSlider.addEventListener('input', (event) => {
                const minutesOffset = parseInt(event.target.value); currentTime = new Date(initialTime.getTime() + minutesOffset * 60000);
                updateSatellitePositions(true); updateTimeDisplay(); if (targetSatelliteObject) drawOrbitPathForSatellite(targetSatelliteObject.userData);
            });
            timePlayPauseBtn.addEventListener('click', () => { timePaused = !timePaused; timePlayPauseBtn.textContent = timePaused ? "Play" : "Pause"; });
            timeRewindBtn.addEventListener('click', () => { timeScale = Math.max(0.1, timeScale / 2); updateTimeSpeedDisplay(); });
            timeForwardBtn.addEventListener('click', () => { timeScale = Math.min(1024*2, timeScale * 2); updateTimeSpeedDisplay(); });
            timeResetBtn.addEventListener('click', () => {
                currentTime = new Date(initialTime); timeScale = 1; timePaused = false; timePlayPauseBtn.textContent = "Pause";
                timelineSlider.value = 0; updateTimeSpeedDisplay(); updateTimeDisplay(); updateSatellitePositions(true);
                if (targetSatelliteObject) drawOrbitPathForSatellite(targetSatelliteObject.userData);
            });
            updateTimeSpeedDisplay();
        }
        function updateTimeSpeedDisplay() { timeSpeedDisplay.textContent = `${timeScale}x`; }
        function updateTimeDisplay() {
            timeDisplay.textContent = `Sim Time: ${currentTime.toLocaleTimeString()} UTC`;
            const diffMinutes = (currentTime.getTime() - initialTime.getTime()) / 60000;
            timelineSlider.value = Math.round(Math.max(0, Math.min(timelineSlider.max, diffMinutes)));
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onPointerDown(event) {
            let targetElement = event.target;
            while(targetElement != null) {
                if (targetElement.id === 'info-panel' || targetElement.id === 'filter-panel' || targetElement.id === 'search-overlay' || targetElement.id === 'timeline-container' || targetElement.id === 'main-controls-bar') return;
                targetElement = targetElement.parentElement;
            }
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const visibleSatelliteMeshes = Array.from(satelliteObjects.values()).filter(mesh => mesh.visible);
            const intersects = raycaster.intersectObjects(visibleSatelliteMeshes);
            if (intersects.length > 0) {
                const newIntersectedObject = intersects[0].object;
                if (targetSatelliteObject !== newIntersectedObject) selectSatellite(newIntersectedObject);
            } else { if (!infoPanel.classList.contains('visible')) { deselectSatellite(); } }
        }
        function selectSatellite(satObject) {
            if (targetSatelliteObject) { targetSatelliteObject.material = satObject.userData.defaultMaterial; }
            targetSatelliteObject = satObject; targetSatelliteObject.material = satObject.userData.selectedMaterial;
            displaySatelliteInfo(targetSatelliteObject.userData); drawOrbitPathForSatellite(targetSatelliteObject.userData);
            focusOnSatelliteCamera(targetSatelliteObject); isFollowingSatellite = false; updateFollowButton(); showInfoPanel();
        }
        function deselectSatellite() {
            if (targetSatelliteObject) { targetSatelliteObject.material = targetSatelliteObject.userData.defaultMaterial; }
            targetSatelliteObject = null; clearOrbitPath(); isFollowingSatellite = false; updateFollowButton(); controls.autoRotate = false;
        }
        function displaySatelliteInfo(satData) {
            document.getElementById('sat-name-header').textContent = satData.name || 'Satellite Info';
            document.getElementById('sat-name').textContent = satData.name || 'N/A';
            document.getElementById('sat-norad-id').textContent = satData.noradId || 'N/A';
            document.getElementById('sat-intl-des').textContent = satData.intlDes || 'N/A';
            document.getElementById('sat-launch-date').textContent = satData.launchDate?.substring(0,10) || 'N/A';
            document.getElementById('sat-launch-year').textContent = satData.launchYear || 'N/A';
            document.getElementById('sat-country').textContent = satData.country || 'N/A';
            document.getElementById('sat-orbit-type').textContent = satData.orbitType || 'N/A';
            document.getElementById('sat-constellation').textContent = satData.constellation || 'N/A';
            updateLiveInfoPanel(satData);
        }
        function updateLiveInfoPanel(satData){
            document.getElementById('sat-altitude').textContent = satData.altitude ? satData.altitude.toFixed(0) : 'N/A';
            document.getElementById('sat-velocity').textContent = satData.velocity ? satData.velocity.toFixed(1) : 'N/A';
            document.getElementById('sat-period').textContent = satData.periodMinutes ? satData.periodMinutes.toFixed(0) : 'N/A';
            document.getElementById('sat-inclination').textContent = satData.inclinationDeg ? satData.inclinationDeg.toFixed(1) : 'N/A';
            document.getElementById('sat-lat').textContent = satData.latitude ? satData.latitude.toFixed(2) : 'N/A';
            document.getElementById('sat-lon').textContent = satData.longitude ? satData.longitude.toFixed(2) : 'N/A';
        }
        function drawOrbitPathForSatellite(satData) {
            if (!satData || !satData.satrec) return; clearOrbitPath();
            const points = []; const segments = 90; const orbitDurationMinutes = satData.periodMinutes || 90;
            const timeStepMinutes = orbitDurationMinutes / segments; let tempTime = new Date(currentTime.getTime());
            for (let i = 0; i <= segments; i++) {
                try {
                    const pnv = satellite.propagate(satData.satrec, tempTime);
                    if (pnv.position) points.push(new THREE.Vector3( pnv.position.x*SCALE_FACTOR, pnv.position.z*SCALE_FACTOR, -pnv.position.y*SCALE_FACTOR ));
                } catch (e) { }
                tempTime = new Date(tempTime.getTime() + timeStepMinutes * 60000);
            }
            if (points.length > 1) {
                const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00dddd, linewidth: 1, transparent: true, opacity: 0.6 });
                focusedSatellitePathLine = new THREE.Line(pathGeometry, pathMaterial); scene.add(focusedSatellitePathLine);
            }
        }
        function clearOrbitPath() {
            if (focusedSatellitePathLine) {
                scene.remove(focusedSatellitePathLine); focusedSatellitePathLine.geometry.dispose();
                focusedSatellitePathLine.material.dispose(); focusedSatellitePathLine = null;
            }
        }
        function focusOnSatelliteCamera(satelliteObject) { if (!satelliteObject) return; isCameraAnimating = true; controls.autoRotate = false; }
        function toggleFollowSatellite() {
            if (!targetSatelliteObject) return; isFollowingSatellite = !isFollowingSatellite; updateFollowButton();
            if (isFollowingSatellite) isCameraAnimating = false;
        }
        function updateFollowButton() {
            if (isFollowingSatellite && targetSatelliteObject) { followSatelliteToggleBtn.textContent = "Stop Following"; followSatelliteToggleBtn.classList.add('following'); }
            else { followSatelliteToggleBtn.textContent = "Follow Satellite"; followSatelliteToggleBtn.classList.remove('following'); }
            followSatelliteToggleBtn.style.display = targetSatelliteObject ? 'block' : 'none';
        }
        function handleSearch(event) {
            const query = event.target.value.toLowerCase(); searchResultsList.innerHTML = ''; if (query.length < 1) return;
            const results = allSatellitesData.filter(sat => sat.name.toLowerCase().includes(query) || sat.noradId.includes(query)).slice(0, 20);
            if (results.length > 0) { results.forEach(sat => { const li = document.createElement('li'); li.textContent = `${sat.name} (${sat.noradId})`; li.dataset.noradId = sat.noradId; searchResultsList.appendChild(li); }); }
            else { const li = document.createElement('li'); li.textContent = "No satellites found."; li.style.cursor = "default"; searchResultsList.appendChild(li); }
        }
        function handleSearchResultClick(event) {
            if (event.target.tagName === 'LI' && event.target.dataset.noradId) {
                const noradId = event.target.dataset.noradId; const satObject = satelliteObjects.get(noradId);
                if (satObject) { selectSatellite(satObject); toggleSearchOverlay(false); }
            }
        }
        function animateApp() {
            requestAnimationFrame(animateApp); const elapsedDelta = clock.getDelta();
            if(!timePaused){
                const simElapsedTimeMs = elapsedDelta * 1000 * timeScale;
                currentTime = new Date(currentTime.getTime() + simElapsedTimeMs);
                updateTimeDisplay(); updateSatellitePositions();
            }
            const rotationSpeedFactor = (timePaused ? 0.1 : timeScale) * elapsedDelta * 2;
            earth.rotation.y += 0.005 * rotationSpeedFactor;
            if (clouds) clouds.rotation.y += 0.008 * rotationSpeedFactor;
            if (stars) stars.rotation.y += 0.002 * rotationSpeedFactor;
            if (targetSatelliteObject) {
                targetSatelliteObject.getWorldPosition(cameraFocusTargetPosition);
                if (isCameraAnimating) {
                    controls.target.lerp(cameraFocusTargetPosition, 0.08);
                    let alt = targetSatelliteObject.userData.approxAltitudeKm || 1000; let distFactor = 0.08;
                    if (alt < 1000) distFactor = 0.04; else if (alt > 30000) distFactor = 0.2;
                    const offset = new THREE.Vector3().subVectors(camera.position, controls.target).normalize().multiplyScalar(distFactor);
                    desiredCameraPosition.addVectors(cameraFocusTargetPosition, offset);
                    camera.position.lerp(desiredCameraPosition, 0.08);
                    if (camera.position.distanceTo(desiredCameraPosition) < 0.001 && controls.target.distanceTo(cameraFocusTargetPosition) < 0.001) isCameraAnimating = false;
                } else if (isFollowingSatellite) { controls.target.copy(cameraFocusTargetPosition); }
            }
            controls.update(); renderer.render(scene, camera);
        }
    </script>
</body>
</html>
