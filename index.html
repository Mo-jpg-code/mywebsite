<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Dialogue Interface - Model: CerebraSim v2.1</title>
    <style>
        /* Basic styling - you can expand this */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; background-color: #2b2b2b; color: #dcdcdc; }
        .header { padding: 15px; background-color: #3c3c3c; text-align: center; color: #61dafb; font-size: 1.5em; border-bottom: 1px solid #4a4a4a;}
        .chat-container { flex-grow: 1; display: flex; flex-direction: column; padding: 20px; overflow-y: auto; }
        .message { margin-bottom: 10px; padding: 10px 15px; border-radius: 15px; max-width: 70%; line-height: 1.5; }
        .user { background-color: #007bff; color: white; align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai { background-color: #4a4a4a; color: #dcdcdc; align-self: flex-start; border-bottom-left-radius: 5px;}
        .input-area { display: flex; padding: 15px; border-top: 1px solid #4a4a4a; background-color: #3c3c3c; }
        #userInput { flex-grow: 1; padding: 10px; border: 1px solid #555; border-radius: 5px; background-color: #252525; color: #dcdcdc; font-size: 1em;}
        #sendButton, #openMonitorButton { padding: 10px 20px; margin-left: 10px; border: none; border-radius: 5px; cursor: pointer; background-color: #61dafb; color: #2b2b2b; font-weight: bold; }
        #sendButton:hover, #openMonitorButton:hover { background-color: #52badd; }
        .timestamp { font-size: 0.75em; opacity: 0.7; display: block; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="header">
        CerebraSim v2.1 - Dialogue Interface
        <button id="openMonitorButton" style="font-size: 0.6em; padding: 5px 10px; float: right;">Open AI Core Monitor</button>
    </div>

    <div class="chat-container" id="chatLog">
        <!-- Messages will appear here -->
    </div>

    <div class="input-area">
        <input type="text" id="userInput" placeholder="Type your message...">
        <button id="sendButton">Send</button>
    </div>

    <script>
        const chatLog = document.getElementById('chatLog');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const openMonitorButton = document.getElementById('openMonitorButton');
        let monitorWindow = null;

        const START_TOKEN = "_START_";
        const END_TOKEN = "_END_";

        let aiState = {
            parameters: {
                learningRate: 0.05, // How quickly KB weights adapt
                confidence: 0.6,    // General confidence, affects response directness
                curiosity: 0.3,     // Bias towards asking questions or exploring new topics
                verbosity: 0.7,     // Controls length of n-gram generated responses
                ngramPreference: 0.7, // Likelihood to use n-grams vs KB
                kbConfidenceThreshold: 0.5, // Min confidence for a KB fact to be used
            },
            memory: {
                vocabulary: new Set([START_TOKEN, END_TOKEN]),
                bigrams: {}, // { "word1": { "word2": count, ... } }
                trigrams: {}, // { "word1 word2": { "word3": count, ... } }
                knowledgeBase: {}, // { "entity": { "relation": "value" / {"value": X, "confidence": Y} } }
                                   // e.g. {"sky": {"is": {"value": "blue", "confidence": 0.8}}}
                conversationHistory: [], // {sender, text, tokens, timestamp, analysis: {intent, keywords}}
            },
            status: "Initializing...",
            lastThoughtProcess: []
        };

        function openOrFocusMonitor() {
            if (monitorWindow && !monitorWindow.closed) {
                monitorWindow.focus();
            } else {
                monitorWindow = window.open('monitor.html', 'AICoreMonitor', 'width=800,height=700,resizable=yes,scrollbars=yes');
                // Give monitor time to load, then send initial state
                setTimeout(() => {
                    if (monitorWindow) {
                         postToMonitor({ type: 'INIT', data: aiState });
                    }
                }, 1000);
            }
        }
        openMonitorButton.addEventListener('click', openOrFocusMonitor);

        function postToMonitor(message) {
            if (monitorWindow && !monitorWindow.closed) {
                monitorWindow.postMessage(message, '*'); // For simplicity, use '*' for origin. In production, specify origin.
            }
        }

        function logToMonitor(entry, type = "thought") {
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 2 });
            const fullEntry = `[${timestamp}] ${entry}`;
            aiState.lastThoughtProcess.unshift(fullEntry); // Add to front
            if (aiState.lastThoughtProcess.length > 100) { // Keep log manageable
                aiState.lastThoughtProcess.pop();
            }
            postToMonitor({ type: 'LOG_UPDATE', data: { entry: fullEntry, logType: type } });
        }


        function tokenize(text) {
            return [START_TOKEN, ...text.toLowerCase().match(/\b[\w']+\b|[.,!?]/g) || [], END_TOKEN];
        }

        function loadState() {
            logToMonitor("Attempting to load AI state from localStorage...", "system");
            const savedState = localStorage.getItem('cerebraSimState_v2_1');
            if (savedState) {
                try {
                    const parsed = JSON.parse(savedState);
                    // Restore Sets and potentially other non-JSON-native types
                    parsed.memory.vocabulary = new Set(parsed.memory.vocabulary);
                    // Basic merge: overwrite with saved state, but keep defaults if new params were added
                    aiState.parameters = {...aiState.parameters, ...parsed.parameters};
                    aiState.memory = {...aiState.memory, ...parsed.memory};
                    aiState.memory.vocabulary = new Set(aiState.memory.vocabulary); // Ensure it's a set
                    aiState.memory.knowledgeBase = aiState.memory.knowledgeBase || {};
                    aiState.memory.conversationHistory = aiState.memory.conversationHistory || [];

                    logToMonitor("AI state loaded successfully.", "system");
                } catch (e) {
                    logToMonitor(`Error loading state: ${e}. Initializing fresh state.`, "error");
                    initializeNewState();
                }
            } else {
                logToMonitor("No saved state found. Initializing fresh state.", "system");
                initializeNewState();
            }
            aiState.status = "Idle";
            postToMonitor({ type: 'FULL_STATE_UPDATE', data: aiState });
        }
        
        function initializeNewState() {
            // Already defined in aiState declaration, this is for explicit reset if needed
            aiState.memory.vocabulary = new Set([START_TOKEN, END_TOKEN]);
            aiState.memory.bigrams = {};
            aiState.memory.trigrams = {};
            aiState.memory.knowledgeBase = {};
            aiState.memory.conversationHistory = [];
            addMessageToChatLog("CerebraSim v2.1 initialized. I'm ready to learn.", 'ai');
        }

        function saveState() {
            logToMonitor("Saving AI state to localStorage...", "system");
            try {
                // Convert Set to Array for JSON stringification
                const serializableState = {
                    ...aiState,
                    memory: {
                        ...aiState.memory,
                        vocabulary: Array.from(aiState.memory.vocabulary)
                    }
                };
                localStorage.setItem('cerebraSimState_v2_1', JSON.stringify(serializableState));
            } catch (e) {
                logToMonitor(`Error saving state: ${e}. Might be due to storage limits.`, "error");
            }
        }

        function addMessageToChatLog(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender);
            messageDiv.textContent = text;
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit'});
            const timeSpan = document.createElement('span');
            timeSpan.className = 'timestamp';
            timeSpan.textContent = time;
            messageDiv.appendChild(timeSpan);

            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        // --- Core AI Learning Logic ---
        function learnFromTokens(tokens) {
            logToMonitor(`Learning from ${tokens.length - 2} tokens.`);
            tokens.forEach(token => aiState.memory.vocabulary.add(token));

            for (let i = 0; i < tokens.length - 1; i++) {
                const w1 = tokens[i]; const w2 = tokens[i+1];
                aiState.memory.bigrams[w1] = aiState.memory.bigrams[w1] || {};
                aiState.memory.bigrams[w1][w2] = (aiState.memory.bigrams[w1][w2] || 0) + 1;

                if (i < tokens.length - 2) {
                    const w3 = tokens[i+2]; const trigramKey = `${w1} ${w2}`;
                    aiState.memory.trigrams[trigramKey] = aiState.memory.trigrams[trigramKey] || {};
                    aiState.memory.trigrams[trigramKey][w3] = (aiState.memory.trigrams[trigramKey][w3] || 0) + 1;
                }
            }
            // Simple KB learning (example: "X is Y", "I like Z")
            for (let i = 1; i < tokens.length - 2; i++) { // Skip START/END
                if (tokens[i+1] === 'is' && tokens[i].length > 1 && tokens[i+2].length > 1 && tokens[i+2] !== END_TOKEN) {
                    const entity = tokens[i];
                    const value = tokens[i+2];
                    aiState.memory.knowledgeBase[entity] = aiState.memory.knowledgeBase[entity] || {};
                    const currentFact = aiState.memory.knowledgeBase[entity]['is'];
                    let newConfidence = currentFact ? Math.min(1, currentFact.confidence + aiState.parameters.learningRate) : 0.5;
                    
                    aiState.memory.knowledgeBase[entity]['is'] = { value: value, confidence: newConfidence };
                    logToMonitor(`Learned KB: ${entity} is ${value} (Confidence: ${newConfidence.toFixed(2)})`, "kb_learn");
                }
                // Add more patterns like "I like X", "X has Y", etc.
            }
            postToMonitor({ type: 'MEMORY_UPDATE', data: { vocabularySize: aiState.memory.vocabulary.size, bigrams: aiState.memory.bigrams, trigrams: aiState.memory.trigrams, knowledgeBase: aiState.memory.knowledgeBase } });
        }

        // --- Core AI "Thinking" Logic ---
        async function generateResponse(userTokens, userInputAnalysis) {
            aiState.status = "Thinking...";
            postToMonitor({ type: 'STATUS_UPDATE', data: aiState.status });
            logToMonitor("--- Initiating Response Generation Cycle ---", "cycle");

            let candidates = []; // { text: "...", score: N, source: "description", tokens: [] }

            // Strategy 1: Check Knowledge Base for direct answers or relevant facts
            if (userInputAnalysis.keywords.length > 0) {
                logToMonitor("Strategy: Knowledge Base Lookup", "strategy");
                for (const keyword of userInputAnalysis.keywords) {
                    if (aiState.memory.knowledgeBase[keyword]) {
                        for (const relation in aiState.memory.knowledgeBase[keyword]) {
                            const fact = aiState.memory.knowledgeBase[keyword][relation];
                            if (fact.confidence >= aiState.parameters.kbConfidenceThreshold) {
                                let responseText = "";
                                if (userInputAnalysis.intent === "question_what" && relation === "is") {
                                    responseText = `${keyword} ${relation} ${fact.value}.`;
                                } else {
                                    responseText = `Regarding ${keyword}, I know that ${keyword} ${relation} ${fact.value}.`;
                                }
                                candidates.push({ text: responseText, score: 70 + fact.confidence * 30, source: "KB Fact", tokens: tokenize(responseText) });
                                logToMonitor(`  KB Candidate: "${responseText.substring(0,50)}..." (Score: ${candidates[candidates.length-1].score.toFixed(0)})`, "candidate");
                            }
                        }
                    }
                }
            }
            
            // Strategy 2: N-gram continuation from user's last words
            logToMonitor("Strategy: N-gram Continuation", "strategy");
            let ngramContext1 = START_TOKEN, ngramContext2 = START_TOKEN;
            if (userTokens.length > 2) ngramContext2 = userTokens[userTokens.length - 2]; // word before END
            if (userTokens.length > 3) ngramContext1 = userTokens[userTokens.length - 3]; // word before that

            let ngramResponseTokens = [];
            let tempContext1 = ngramContext1;
            let tempContext2 = ngramContext2;
            
            for(let i=0; i < 5 + Math.floor(Math.random() * 10 * aiState.parameters.verbosity) ; i++) { // Generate a short phrase
                let nextWord = null;
                const trigramKey = `${tempContext1} ${tempContext2}`;
                if (aiState.memory.trigrams[trigramKey] && Math.random() < 0.8) { // Prefer trigrams
                    nextWord = getWeightedRandom(aiState.memory.trigrams[trigramKey]);
                } else if (aiState.memory.bigrams[tempContext2]) {
                    nextWord = getWeightedRandom(aiState.memory.bigrams[tempContext2]);
                }
                if (!nextWord || nextWord === END_TOKEN) break;
                if (nextWord !== START_TOKEN) ngramResponseTokens.push(nextWord);
                tempContext1 = tempContext2;
                tempContext2 = nextWord;
                if (ngramResponseTokens.length > 25) break; // Safety break for length
            }
            if (ngramResponseTokens.length > 0) {
                const ngramText = formatResponseTokens(ngramResponseTokens);
                candidates.push({ text: ngramText, score: 50 * aiState.parameters.ngramPreference, source: "N-gram Continuation", tokens: [START_TOKEN, ...ngramResponseTokens, END_TOKEN] });
                logToMonitor(`  N-gram Candidate: "${ngramText.substring(0,50)}..." (Score: ${candidates[candidates.length-1].score.toFixed(0)})`, "candidate");
            }


            // Strategy 3: Generic N-gram start if confidence is low or other strategies fail
            if (candidates.length === 0 || aiState.parameters.confidence < 0.4) {
                logToMonitor("Strategy: Generic N-gram Start", "strategy");
                let genericNgramTokens = [];
                tempContext1 = START_TOKEN; tempContext2 = START_TOKEN;
                let initialWord = getWeightedRandom(aiState.memory.bigrams[START_TOKEN]);
                if (initialWord && initialWord !== END_TOKEN) {
                    genericNgramTokens.push(initialWord);
                    tempContext2 = initialWord;
                    for(let i=0; i < 3 + Math.floor(Math.random() * 7 * aiState.parameters.verbosity) ; i++) {
                        let nextWord = null;
                        const trigramKey = `${tempContext1} ${tempContext2}`;
                         if (aiState.memory.trigrams[trigramKey] && Math.random() < 0.7) {
                            nextWord = getWeightedRandom(aiState.memory.trigrams[trigramKey]);
                        } else if (aiState.memory.bigrams[tempContext2]) {
                            nextWord = getWeightedRandom(aiState.memory.bigrams[tempContext2]);
                        }
                        if (!nextWord || nextWord === END_TOKEN) break;
                        genericNgramTokens.push(nextWord);
                        tempContext1 = tempContext2;
                        tempContext2 = nextWord;
                        if (genericNgramTokens.length > 20) break;
                    }
                }
                 if (genericNgramTokens.length > 0) {
                    const genericText = formatResponseTokens(genericNgramTokens);
                    candidates.push({ text: genericText, score: 30, source: "Generic N-gram", tokens: [START_TOKEN, ...genericNgramTokens, END_TOKEN] });
                    logToMonitor(`  Generic N-gram Candidate: "${genericText.substring(0,50)}..." (Score: ${candidates[candidates.length-1].score.toFixed(0)})`, "candidate");
                }
            }

            // Fallback if no candidates
            if (candidates.length === 0) {
                 logToMonitor("No candidates generated, using fallback.", "warn");
                const fallbackText = "I'm still processing that. Could you tell me more?";
                candidates.push({ text: fallbackText, score: 10, source: "Fallback", tokens: tokenize(fallbackText)});
            }

            // Score and select best candidate
            candidates.sort((a, b) => b.score - a.score); // Highest score first
            const bestCandidate = candidates[0];
            logToMonitor(`Selected Best Candidate (out of ${candidates.length}): "${bestCandidate.text.substring(0,50)}..." (Score: ${bestCandidate.score.toFixed(0)}, Source: ${bestCandidate.source})`, "decision");
            
            // Simulate parameter adjustment based on interaction (very simple)
            if (bestCandidate.source === "KB Fact") aiState.parameters.confidence = Math.min(0.95, aiState.parameters.confidence + 0.02);
            else aiState.parameters.confidence = Math.max(0.2, aiState.parameters.confidence - 0.01);
            if (userInputAnalysis.intent === "question_what") aiState.parameters.curiosity = Math.max(0.1, aiState.parameters.curiosity - 0.05); // Less curious if it answered
            else aiState.parameters.curiosity = Math.min(0.8, aiState.parameters.curiosity + 0.01);

            aiState.status = "Idle";
            postToMonitor({ type: 'FULL_STATE_UPDATE', data: aiState }); // Update monitor with new params etc.
            logToMonitor("--- Response Generation Cycle Complete ---", "cycle");
            return bestCandidate;
        }

        function getWeightedRandom(choices) { // { "word": count }
            if (!choices || Object.keys(choices).length === 0) return null;
            let total = 0;
            for (const count of Object.values(choices)) total += count;
            let rand = Math.random() * total;
            for (const [word, count] of Object.entries(choices)) {
                rand -= count;
                if (rand <= 0) return word;
            }
            return Object.keys(choices)[0]; // Should not happen if counts are positive
        }
        
        function formatResponseTokens(tokens) {
            if (!tokens || tokens.length === 0) return "";
            let text = tokens.join(' ').replace(/\s+([.,!?])/g, '$1');
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        function analyzeUserInput(text, tokens) {
            logToMonitor(`Analyzing user input: "${text.substring(0,50)}..."`);
            const analysis = {
                intent: "statement", // default
                keywords: [],
                sentiment: "neutral" // very basic
            };

            const lowerText = text.toLowerCase();
            if (lowerText.startsWith("what is") || lowerText.startsWith("what's")) analysis.intent = "question_what";
            else if (lowerText.includes("?")) analysis.intent = "question_generic";
            
            // Simple keyword extraction (non-stopwords, longer words)
            const stopwords = new Set(['_start_', '_end_', 'a', 'an', 'the', 'is', 'are', 'was', 'were', 'i', 'you', 'me', 'he', 'she', 'it', 'we', 'they', 'to', 'of', 'in', 'on', 'for', 'with']);
            analysis.keywords = tokens.filter(t => !stopwords.has(t.toLowerCase()) && t.length > 2).slice(0, 5); // Max 5 keywords

            logToMonitor(`  Analysis - Intent: ${analysis.intent}, Keywords: ${analysis.keywords.join(', ') || 'None'}`);
            return analysis;
        }

        // --- Main Interaction Loop ---
        async function handleUserInput() {
            const text = userInput.value.trim();
            if (text === '') return;

            addMessageToChatLog(text, 'user');
            const userTokens = tokenize(text);
            const userInputAnalysis = analyzeUserInput(text, userTokens.slice(1,-1)); // Analyze without START/END

            aiState.memory.conversationHistory.push({
                sender: 'user', text, tokens: userTokens, timestamp: new Date().toISOString(), analysis: userInputAnalysis
            });
            if(aiState.memory.conversationHistory.length > 50) aiState.memory.conversationHistory.shift();


            userInput.value = '';
            userInput.disabled = true; sendButton.disabled = true;

            learnFromTokens(userTokens); // AI learns from user input

            const aiResponse = await generateResponse(userTokens, userInputAnalysis);
            addMessageToChatLog(aiResponse.text, 'ai');
            learnFromTokens(aiResponse.tokens); // AI learns from its own response

            aiState.memory.conversationHistory.push({
                sender: 'ai', text: aiResponse.text, tokens: aiResponse.tokens, timestamp: new Date().toISOString(), analysis: {intent: "response", keywords: []}
            });

            saveState();

            userInput.disabled = false; sendButton.disabled = false;
            userInput.focus();
        }

        sendButton.addEventListener('click', handleUserInput);
        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') handleUserInput();
        });

        // --- Initialization ---
        window.onload = () => {
            loadState();
            // Optionally open monitor on load: openOrFocusMonitor();
            addMessageToChatLog("CerebraSim v2.1 online. Type 'Open AI Core Monitor' or click the button to view my internals.", 'ai');
        };

    </script>
</body>
</html>
