<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MinoGPT Studio Pro</title>

    <!-- Google AI SDK -->
    <script type="module">
        try {
            // Importiere direkt aus dem Google CDN für die neueste Version
            const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = await import('https://esm.run/@google/generative-ai');
            window.GoogleGenerativeAI = GoogleGenerativeAI;
            window.HarmCategory = HarmCategory; // Global verfügbar machen
            window.HarmBlockThreshold = HarmBlockThreshold; // Global verfügbar machen
            console.log("Google AI SDK geladen.");
            // Signalisiere, dass das SDK bereit ist (wird im Hauptscript verwendet)
            document.dispatchEvent(new Event('google-ai-sdk-ready'));
        } catch (error) {
            console.error("Fehler beim Laden des Google AI SDK:", error);
            alert("Schwerwiegender Fehler: Google AI SDK konnte nicht geladen werden. Die App kann nicht initialisiert werden. Prüfen Sie die Browserkonsole und Ihre Netzwerkverbindung.");
            // Verhindere weitere Ausführung, wenn SDK fehlt
            document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: sans-serif;">Fehler beim Laden des Google AI SDK. App kann nicht starten.</div>';
        }
    </script>

    <style>
        /* --- Globale Stile & Variablen (Modern/Minimalistisch) --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @import url("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"); /* Update Font Awesome */

        :root {
            --font-family: 'Inter', sans-serif;
            --bg-color: #121218; /* Sehr dunkles Grau, leicht bläulich */
            --sidebar-bg: #1a1a22;
            --chat-bg: #1e1e26;
            --input-bg: #252530;
            --primary-color: #f0f0f5; /* Fast weiß, leicht kühl */
            --secondary-color: #a0a0b0; /* Helleres Grau für weniger wichtige Texte */
            --accent-color: #36a3ff; /* Helles, modernes Blau */
            --accent-hover-color: #66bfff;
            --border-color: #353540; /* Subtiler als zuvor */
            --shadow-color: rgba(54, 163, 255, 0.1); /* Passend zum Akzent */
            --error-color: #ff5555;
            --success-color: #4caf50;
            --warning-color: #ffc107;
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --transition-speed: 0.25s;
            --font-size-base: 14px;
            --font-size-sm: 12px;
            --font-size-lg: 16px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--border-color) transparent; /* Firefox */
        }
        /* Webkit Scrollbars */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 3px; border: 1px solid transparent; }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--secondary-color); }


        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-color);
            display: flex;
            font-size: var(--font-size-base);
            line-height: 1.6;
        }

        /* --- Hauptlayout (Sidebar + Main Content) --- */
        .studio-layout { display: flex; width: 100%; height: 100%; }

        /* --- Sidebar --- */
        .sidebar {
            width: 250px; /* Etwas schmaler */
            background-color: var(--sidebar-bg);
            /* border-right: 1px solid var(--border-color); */ /* Rahmen entfernt für cleaneren Look */
            display: flex;
            flex-direction: column;
            padding: 15px 0;
            transition: width var(--transition-speed) ease;
            animation: slideInSidebar 0.5s ease-out;
            flex-shrink: 0;
        }
        @keyframes slideInSidebar { from { transform: translateX(-100%); } to { transform: translateX(0); } }

        .sidebar-header { padding: 0 15px 15px 15px; margin-bottom: 10px; }
        .sidebar-logo { font-size: 1.5em; font-weight: 700; color: var(--primary-color); letter-spacing: 0.5px; text-align: center; }
        .sidebar-logo span { color: var(--accent-color); }

        .new-chat-button {
            display: flex; align-items: center; justify-content: center; gap: 8px;
            background-color: transparent; /* Standard transparent */
            color: var(--primary-color);
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius-md); padding: 10px 15px;
            margin: 0 15px 15px 15px; font-size: var(--font-size-base); font-weight: 500;
            cursor: pointer; transition: all var(--transition-speed) ease; text-align: center;
        }
        .new-chat-button:hover { background-color: var(--accent-color); color: var(--bg-color); transform: translateY(-1px); box-shadow: 0 3px 8px var(--shadow-color); }
        .new-chat-button i { font-size: 0.9em; }

        .history-section { flex-grow: 1; overflow-y: auto; padding: 0 5px; }
        .history-section h3 { padding: 10px 10px; font-size: var(--font-size-sm); text-transform: uppercase; color: var(--secondary-color); letter-spacing: 0.5px; font-weight: 500; }
        #history-list { list-style: none; }

        .history-item {
            display: flex; align-items: center; justify-content: space-between; gap: 5px;
            padding: 8px 12px; margin: 0 5px 4px 5px; border-radius: var(--border-radius-sm);
            cursor: pointer; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.95em; color: var(--secondary-color);
        }
        .history-item:hover { background-color: var(--input-bg); color: var(--primary-color); }
        .history-item.active { background-color: var(--accent-color); color: var(--bg-color) !important; font-weight: 500; }
        .history-item.active:hover { background-color: var(--accent-hover-color); }
        .history-item i.fa-comment-dots { margin-right: 8px; font-size: 0.9em; flex-shrink: 0; }
        .history-item .history-title { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; }

        .delete-chat-btn {
            background: none; border: none; color: inherit; /* Erbt Farbe vom Parent */
            cursor: pointer; padding: 3px; margin-left: 5px;
            font-size: 0.9em; opacity: 0; /* Standardmäßig unsichtbar */
            transition: opacity 0.2s ease, color 0.2s ease; flex-shrink: 0;
        }
        .history-item:hover .delete-chat-btn { opacity: 0.6; }
        .history-item .delete-chat-btn:hover { opacity: 1; color: var(--error-color); }
        .history-item.active .delete-chat-btn { opacity: 0.7; }
        .history-item.active .delete-chat-btn:hover { opacity: 1; color: #ff2222; }


        .sidebar-footer { padding: 10px 15px 0 15px; border-top: 1px solid var(--border-color); margin-top: 10px; }
        .sidebar-button {
            display: flex; align-items: center; gap: 10px; width: 100%; background: none; border: none;
            color: var(--secondary-color); padding: 10px; border-radius: var(--border-radius-sm);
            cursor: pointer; text-align: left; font-size: 0.95em;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        .sidebar-button i { width: 16px; text-align: center; font-size: 1em; }
        .sidebar-button:hover { background-color: var(--input-bg); color: var(--primary-color); }

        /* --- Haupt-Chatbereich --- */
        .main-content { flex-grow: 1; display: flex; flex-direction: column; background-color: var(--chat-bg); height: 100%; animation: fadeInMain 0.7s ease-out; }
        @keyframes fadeInMain { from { opacity: 0; } to { opacity: 1; } }

        /* --- Chat Fenster --- */
        .chat-window { flex-grow: 1; padding: 25px 30px; overflow-y: auto; scroll-behavior: smooth; }

        .message { display: flex; gap: 12px; margin-bottom: 20px; opacity: 0; animation: fadeInMessage 0.4s ease forwards; max-width: 90%; line-height: 1.6; }
        @keyframes fadeInMessage { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        .message-avatar {
            width: 32px; height: 32px; border-radius: 50%; background-color: var(--input-bg);
            color: var(--accent-color); display: flex; align-items: center; justify-content: center;
            font-weight: 500; font-size: 1.1em; flex-shrink: 0; margin-top: 2px; /* Align top better */
        }
        .user-message .message-avatar { background-color: var(--accent-color); color: var(--bg-color); }

        .message-content-wrapper { display: flex; flex-direction: column; max-width: calc(100% - 44px); /* Avatar + gap */ }
        .message-content { padding: 12px 16px; border-radius: var(--border-radius-md); background-color: var(--input-bg); word-wrap: break-word; white-space: pre-wrap; /* Wichtig für Code etc. */ }

        .user-message { margin-left: auto; flex-direction: row-reverse; }
        .user-message .message-content { background-color: var(--accent-color); color: var(--bg-color); border-bottom-right-radius: var(--border-radius-sm); }
        .ai-message { margin-right: auto; }
        .ai-message .message-content { background-color: var(--input-bg); border-bottom-left-radius: var(--border-radius-sm); }

        /* Bildanzeige in Nachrichten */
        .message-content img { max-width: 100%; max-height: 300px; border-radius: var(--border-radius-sm); margin-top: 10px; display: block; }

        .typing-indicator { display: flex; align-items: center; padding-left: 44px; /* Avatar-Breite + gap */ }
        .typing-indicator span { height: 7px; width: 7px; margin: 0 2px; background-color: var(--accent-color); border-radius: 50%; opacity: 0.6; animation: bounce 1.4s infinite ease-in-out both; }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); opacity: 0.4; } 40% { transform: scale(1.0); opacity: 1; } }

        .error-message .message-content { background-color: rgba(255, 85, 85, 0.2); border: 1px solid var(--error-color); color: var(--primary-color); }
        .error-message .message-avatar { background-color: var(--error-color); color: white; }

        /* --- Eingabebereich --- */
        .input-area-wrapper { padding: 15px 30px; border-top: 1px solid var(--border-color); background: var(--input-bg); flex-shrink: 0; }
        .input-area { display: flex; align-items: flex-end; gap: 10px; background-color: var(--chat-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 8px; }

        #prompt-input {
            flex-grow: 1; background: transparent; border: none; padding: 10px;
            color: var(--primary-color); font-family: var(--font-family); font-size: var(--font-size-base);
            resize: none; min-height: 40px; max-height: 180px; overflow-y: auto; line-height: 1.5;
            outline: none;
        }
        #prompt-input::placeholder { color: var(--secondary-color); }

        .input-buttons { display: flex; gap: 8px; }
        .input-button {
            background-color: transparent; color: var(--secondary-color); border: none;
            border-radius: var(--border-radius-sm); padding: 0 12px; font-size: 1.3em;
            cursor: pointer; height: 40px; width: 40px; display: flex; align-items: center; justify-content: center;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        .input-button:hover { background-color: var(--border-color); color: var(--primary-color); }
        .input-button:disabled { color: #555; cursor: not-allowed; background-color: transparent; }
        .input-button.send-button { color: var(--accent-color); }
        .input-button.send-button:hover { background-color: rgba(54, 163, 255, 0.1); }
        .input-button.stop-button { color: var(--error-color); display: none; }
        .input-button.stop-button:hover { background-color: rgba(255, 85, 85, 0.1); }

        /* Versteckter File Input */
        #image-upload-input { display: none; }

        /* --- Einstellungs-Modal --- */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); animation: fadeInModalBg 0.3s ease; }
        @keyframes fadeInModalBg { from { opacity: 0; } to { opacity: 1; } }
        .modal-content {
            background-color: var(--input-bg); margin: 5% auto; padding: 30px 35px; border: none; /* Rand entfernt */
            width: 90%; max-width: 750px; border-radius: var(--border-radius-md);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4); position: relative; animation: slideInModal 0.4s ease-out;
        }
        @keyframes slideInModal { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .close-button { color: var(--secondary-color); position: absolute; top: 15px; right: 20px; font-size: 1.6em; font-weight: bold; cursor: pointer; transition: color var(--transition-speed) ease; }
        .close-button:hover { color: var(--accent-color); }
        .modal-content h2 { color: var(--primary-color); margin-bottom: 25px; text-align: center; font-weight: 600; font-size: 1.4em; }

        .settings-section { margin-bottom: 30px; }
        .settings-section h3 { font-size: 1.1em; color: var(--accent-color); margin-bottom: 15px; padding-bottom: 5px; border-bottom: 1px solid var(--border-color); font-weight: 600;}

        .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px 30px; }
        .setting-item { display: flex; flex-direction: column; gap: 8px; } /* Gap für Label und Input */

        .setting-item label { color: var(--primary-color); font-weight: 500; font-size: 0.9em; }
        .setting-item label small { color: var(--secondary-color); font-weight: 400; display: block; margin-top: 2px; font-size: 0.85em; }
        .setting-item .setting-value { font-weight: 500; color: var(--accent-color); margin-left: 5px; }

        .setting-item input[type="text"],
        .setting-item input[type="password"],
        .setting-item input[type="number"],
        .setting-item select,
        .setting-item textarea {
            width: 100%; padding: 10px 12px; background-color: var(--chat-bg); border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm); color: var(--primary-color); font-family: var(--font-family); font-size: 0.95em;
            transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        .setting-item input:focus, .setting-item select:focus, .setting-item textarea:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 2px rgba(54, 163, 255, 0.3); }
        .setting-item select { cursor: pointer; }
        .setting-item textarea { min-height: 80px; resize: vertical; }
        .setting-item input[type="range"] { width: 100%; cursor: pointer; height: 5px; -webkit-appearance: none; appearance: none; background: var(--border-color); border-radius: 5px; outline: none; }
        .setting-item input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--accent-color); border-radius: 50%; cursor: pointer; }
        .setting-item input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; background: var(--accent-color); border-radius: 50%; cursor: pointer; border: none; }


        .api-key-wrapper { position: relative; }
        .toggle-visibility { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--secondary-color); cursor: pointer; font-size: 1.1em; padding: 5px; }
        .toggle-visibility:hover { color: var(--accent-color); }

        .safety-settings-grid { display: grid; grid-template-columns: 1fr auto; gap: 10px 15px; align-items: center; }
        .safety-settings-grid label { font-weight: 400; }
        .safety-settings-grid select { max-width: 200px; } /* Verhindert, dass Select zu breit wird */

        .settings-actions { margin-top: 30px; text-align: right; }
        .save-settings-btn {
            background-color: var(--accent-color); color: var(--bg-color); border: none; padding: 10px 25px;
            border-radius: var(--border-radius-md); cursor: pointer; font-weight: 600; font-size: 0.95em;
            transition: background-color var(--transition-speed) ease, transform 0.1s ease;
        }
        .save-settings-btn:hover { background-color: var(--accent-hover-color); transform: translateY(-1px); }
        .save-settings-btn:active { transform: translateY(0); }

        /* Warnhinweise */
        .inline-warning, .inline-info { padding: 10px 15px; margin-bottom: 20px; border-radius: var(--border-radius-sm); font-size: 0.9em; border: 1px solid; display: flex; align-items: center; gap: 10px; }
        .inline-warning { background-color: rgba(255, 193, 7, 0.1); border-color: var(--warning-color); color: var(--warning-color); }
        .inline-warning strong { color: inherit; }
        .inline-info { background-color: rgba(54, 163, 255, 0.1); border-color: var(--accent-color); color: var(--accent-color); }
        .inline-warning i, .inline-info i { font-size: 1.2em; }

        /* --- Status-Nachricht unten --- */
        .status-bar {
             padding: 5px 30px;
             font-size: var(--font-size-sm);
             color: var(--secondary-color);
             background-color: var(--sidebar-bg); /* Passend zur Sidebar */
             border-top: 1px solid var(--border-color);
             text-align: right;
             flex-shrink: 0;
         }
         #token-count-display { margin-left: 15px; }
         #token-count-display .value { color: var(--primary-color); font-weight: 500; }

    </style>
</head>
<body>

    <div class="studio-layout">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-logo">Mino<span>GPT</span></div>
            </div>

            <button class="new-chat-button" id="new-chat-btn">
                <i class="fas fa-plus"></i> Neuer Chat
            </button>

            <div class="history-section">
                <h3>Verlauf</h3>
                <ul id="history-list"></ul>
            </div>

            <div class="sidebar-footer">
                <button class="sidebar-button" id="settings-button">
                    <i class="fas fa-cog"></i> Einstellungen
                </button>
                 <button class="sidebar-button" id="clear-history-btn">
                    <i class="fas fa-trash-alt"></i> Verlauf löschen
                </button>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="main-content">
            <div class="chat-window" id="chat-window">
                <!-- Startnachricht oder Chatverlauf -->
            </div>

            <div class="input-area-wrapper">
                 <div id="api-warning-banner" class="inline-warning" style="display: none; margin-bottom: 10px;">
                     <i class="fas fa-exclamation-triangle"></i> <strong>Sicherheitshinweis:</strong> API-Schlüssel ist im Code/LocalStorage sichtbar. Nur für Demo-Zwecke verwenden! Niemals in Produktion einsetzen.
                 </div>
                <div class="input-area">
                    <textarea id="prompt-input" placeholder="Ihre Anfrage an MinoGPT (Shift+Enter für Zeilenumbruch)..." rows="1"></textarea>
                    <div class="input-buttons">
                         <input type="file" id="image-upload-input" accept="image/*">
                         <button class="input-button" id="image-upload-button" title="Bild hochladen">
                             <i class="fas fa-image"></i>
                         </button>
                        <button class="input-button send-button" id="send-button" title="Senden (Enter)">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                         <button class="input-button stop-button" id="stop-button" title="Generierung stoppen">
                             <i class="fas fa-stop"></i>
                         </button>
                    </div>
                </div>
            </div>
             <div class="status-bar" id="status-bar">
                 Status: Bereit
                 <span id="token-count-display" style="display: none;"> | Tokens: <span class="value">0</span></span>
             </div>
        </main>
    </div>

    <!-- Einstellungs-Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="close-settings">&times;</span>
            <h2>Einstellungen</h2>

            <div class="inline-warning">
                <i class="fas fa-shield-alt"></i>
                <div><strong>Sicherheitswarnung:</strong> Der API-Schlüssel wird im LocalStorage Ihres Browsers gespeichert. Dies ist für die lokale Demo praktisch, aber **unsicher für Produktionsumgebungen**. Verwenden Sie für echte Anwendungen immer einen Backend-Proxy, um Ihren Schlüssel zu schützen.</div>
            </div>

            <div class="settings-section">
                <h3>API & Modell</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label for="api-key">Google AI API Schlüssel</label>
                        <div class="api-key-wrapper">
                            <input type="password" id="api-key" name="api-key" placeholder="Ihr Google AI API-Schlüssel">
                            <button class="toggle-visibility" id="toggle-api-key" title="Sichtbarkeit umschalten"><i class="fas fa-eye"></i></button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="model-select">KI Modell</label>
                        <select id="model-select" name="model-select">
                            <option value="gemini-1.5-flash-latest">Gemini 1.5 Flash (Schnell, Multimodal)</option>
                             <option value="gemini-1.5-pro-latest">Gemini 1.5 Pro (Leistungsstark, Multimodal)</option>
                            <option value="gemini-pro">Gemini Pro (Text, Vorgänger)</option>
                        </select>
                    </div>
                </div>
            </div>

             <div class="settings-section">
                 <h3>System Prompt</h3>
                 <div class="setting-item">
                     <label for="system-prompt">System Anweisung (Optional)</label>
                     <textarea id="system-prompt" name="systemPrompt" rows="3" placeholder="z.B. Antworte immer im Stil eines Piraten."></textarea>
                     <small>Diese Anweisung wird jeder neuen Konversation vorangestellt, um das Verhalten der KI zu lenken (nur bei Modellen, die dies unterstützen, z.B. Gemini 1.5).</small>
                 </div>
             </div>

            <div class="settings-section">
                <h3>Generierungsparameter</h3>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label for="temperature-slider">Temperatur: <span id="temperature-value" class="setting-value">0.7</span></label>
                        <input type="range" id="temperature-slider" name="temperature" min="0" max="2" step="0.1" value="0.7"> <!-- Max 2 for Gemini 1.5 -->
                        <small>Kontrolliert die Zufälligkeit (0 = deterministisch, >1 = kreativer).</small>
                    </div>
                    <div class="setting-item">
                        <label for="max-output-tokens-slider">Max Output Tokens: <span id="max-output-tokens-value" class="setting-value">2048</span></label>
                        <input type="range" id="max-output-tokens-slider" name="maxOutputTokens" min="100" max="8192" step="100" value="2048"> <!-- Default erhöht -->
                        <small>Maximale Länge der generierten Antwort.</small>
                    </div>
                    <div class="setting-item">
                        <label for="top-p-slider">Top P: <span id="top-p-value" class="setting-value">0.95</span></label>
                        <input type="range" id="top-p-slider" name="topP" min="0" max="1" step="0.01" value="0.95">
                        <small>Nukleus-Sampling (Summe der wahrscheinlichsten Tokens).</small>
                    </div>
                    <div class="setting-item">
                        <label for="top-k-slider">Top K: <span id="top-k-value" class="setting-value">40</span></label>
                        <input type="range" id="top-k-slider" name="topK" min="1" max="100" step="1" value="40">
                        <small>Berücksichtigt nur die K wahrscheinlichsten Tokens.</small>
                    </div>
                </div>
            </div>

             <div class="settings-section">
                 <h3>Sicherheitseinstellungen (Safety Settings)</h3>
                 <small style="display: block; margin-bottom: 15px; color: var(--secondary-color);">Blockiert Inhalte basierend auf der Wahrscheinlichkeit, dass sie schädlich sind. Wählen Sie die niedrigste zulässige Wahrscheinlichkeitsschwelle.</small>
                 <div class="safety-settings-grid">
                     <label for="safety-harassment">Belästigung (Harassment)</label>
                     <select id="safety-harassment" data-category="HARM_CATEGORY_HARASSMENT">
                         <option value="BLOCK_MEDIUM_AND_ABOVE">Mittel und höher blockieren (Standard)</option>
                         <option value="BLOCK_LOW_AND_ABOVE">Niedrig und höher blockieren</option>
                         <option value="BLOCK_ONLY_HIGH">Nur Hoch blockieren</option>
                         <option value="BLOCK_NONE">Nichts blockieren (Vorsicht)</option>
                     </select>

                     <label for="safety-hate-speech">Hassrede (Hate Speech)</label>
                     <select id="safety-hate-speech" data-category="HARM_CATEGORY_HATE_SPEECH">
                          <option value="BLOCK_MEDIUM_AND_ABOVE">Mittel und höher blockieren (Standard)</option>
                         <option value="BLOCK_LOW_AND_ABOVE">Niedrig und höher blockieren</option>
                         <option value="BLOCK_ONLY_HIGH">Nur Hoch blockieren</option>
                         <option value="BLOCK_NONE">Nichts blockieren (Vorsicht)</option>
                     </select>

                     <label for="safety-sexually-explicit">Sexuell Explizit</label>
                     <select id="safety-sexually-explicit" data-category="HARM_CATEGORY_SEXUALLY_EXPLICIT">
                         <option value="BLOCK_MEDIUM_AND_ABOVE">Mittel und höher blockieren (Standard)</option>
                         <option value="BLOCK_LOW_AND_ABOVE">Niedrig und höher blockieren</option>
                         <option value="BLOCK_ONLY_HIGH">Nur Hoch blockieren</option>
                         <option value="BLOCK_NONE">Nichts blockieren (Vorsicht)</option>
                     </select>

                     <label for="safety-dangerous-content">Gefährlicher Inhalt</label>
                     <select id="safety-dangerous-content" data-category="HARM_CATEGORY_DANGEROUS_CONTENT">
                         <option value="BLOCK_MEDIUM_AND_ABOVE">Mittel und höher blockieren (Standard)</option>
                         <option value="BLOCK_LOW_AND_ABOVE">Niedrig und höher blockieren</option>
                         <option value="BLOCK_ONLY_HIGH">Nur Hoch blockieren</option>
                         <option value="BLOCK_NONE">Nichts blockieren (Vorsicht)</option>
                     </select>
                 </div>
             </div>


            <div class="settings-actions">
                <button id="save-settings-btn" class="save-settings-btn">Einstellungen speichern & anwenden</button>
            </div>

        </div>
    </div>

    <script>
        // --- Globale Variablen und DOM-Elemente ---
        // (DOM Elemente werden in initApp geholt, um sicherzustellen, dass das SDK bereit ist)
        let chatWindow, promptInput, sendButton, stopButton, settingsModal, settingsButton,
            closeSettingsButton, newChatButton, historyList, clearHistoryButton, apiKeyInput,
            toggleApiKeyButton, modelSelect, temperatureSlider, temperatureValue, maxOutputTokensSlider,
            maxOutputTokensValue, topPSlider, topPValue, topKSlider, topKValue, systemPromptInput,
            saveSettingsButton, apiWarningBanner, imageUploadButton, imageUploadInput, statusBar,
            tokenCountDisplay;

        // Safety Settings Selectors
        let safetySelectors = {};

        // --- Zustand der Anwendung ---
        let chatHistory = [];
        let currentChatId = null;
        // WICHTIG: Conversation Parts können jetzt Text ODER Bilder sein
        // Format: { role: 'user'/'model', parts: [ {text: '...'}, {inlineData: {mimeType: '...', data: '...'}} ] }
        let currentConversation = [];
        let settings = {};
        let genAI = null;
        let currentModel = null;
        let isGenerating = false;
        let controller = null; // AbortController
        let sdkReady = false;

        // !!! SICHERHEITSWARNUNG !!! Demo Key (UNSICHER!)
        const DEMO_API_KEY = "AIzaSyAzI9jH-L8Vv5dw7oXQWRt90Ce8UxzSI4U";

        // --- Initialisierung ---
        // Warte auf das benutzerdefinierte Event, das signalisiert, dass das SDK geladen ist
        document.addEventListener('google-ai-sdk-ready', () => {
            sdkReady = true;
            // Führe die Initialisierung erst aus, wenn das SDK definitiv bereit ist
            // und der DOM geladen ist.
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initApp);
            } else {
                initApp(); // DOM bereits geladen
            }
        });

        function initApp() {
            if (!sdkReady) {
                console.error("InitApp called before SDK was ready. This should not happen.");
                return;
            }
            console.log("MinoGPT Studio Initializing...");

            // DOM Elemente holen
            chatWindow = document.getElementById('chat-window');
            promptInput = document.getElementById('prompt-input');
            sendButton = document.getElementById('send-button');
            stopButton = document.getElementById('stop-button');
            settingsModal = document.getElementById('settings-modal');
            settingsButton = document.getElementById('settings-button');
            closeSettingsButton = document.getElementById('close-settings');
            newChatButton = document.getElementById('new-chat-btn');
            historyList = document.getElementById('history-list');
            clearHistoryButton = document.getElementById('clear-history-btn');
            apiKeyInput = document.getElementById('api-key');
            toggleApiKeyButton = document.getElementById('toggle-api-key');
            modelSelect = document.getElementById('model-select');
            temperatureSlider = document.getElementById('temperature-slider');
            temperatureValue = document.getElementById('temperature-value');
            maxOutputTokensSlider = document.getElementById('max-output-tokens-slider');
            maxOutputTokensValue = document.getElementById('max-output-tokens-value');
            topPSlider = document.getElementById('top-p-slider');
            topPValue = document.getElementById('top-p-value');
            topKSlider = document.getElementById('top-k-slider');
            topKValue = document.getElementById('top-k-value');
            systemPromptInput = document.getElementById('system-prompt');
            saveSettingsButton = document.getElementById('save-settings-btn');
            apiWarningBanner = document.getElementById('api-warning-banner');
            imageUploadButton = document.getElementById('image-upload-button');
            imageUploadInput = document.getElementById('image-upload-input');
            statusBar = document.getElementById('status-bar');
            tokenCountDisplay = document.getElementById('token-count-display');

            // Safety Settings Selectors holen
            document.querySelectorAll('.safety-settings-grid select').forEach(sel => {
                safetySelectors[sel.dataset.category] = sel;
            });

            loadSettings(); // Einstellungen laden (oder Defaults setzen)
            loadHistory();  // Verlauf laden
            renderHistoryList(); // Verlauf anzeigen
            setupEventListeners(); // Event Listener registrieren
            updateSettingsUI(); // UI mit geladenen Werten füllen

            // API Key Handling (Demo Key / Warnung)
            if (!settings.apiKey) {
                apiKeyInput.value = DEMO_API_KEY;
                settings.apiKey = DEMO_API_KEY;
                apiWarningBanner.style.display = 'flex';
                saveSettings(); // Speichert Demo Key (für nächsten Start)
                console.warn("Demo API Key pre-filled. THIS IS INSECURE.");
            } else if (settings.apiKey === DEMO_API_KEY) {
                apiWarningBanner.style.display = 'flex';
            }

            // Google AI initialisieren NACHDEM Settings geladen sind
            initializeGoogleAI();

            // Ersten Chat laden oder leeren Zustand anzeigen
            selectChat(chatHistory.length > 0 ? chatHistory[0].id : null);

            console.log("MinoGPT Studio Ready.");
            autoResizeTextarea(); // Initiale Größe der Textarea
            updateStatus("Bereit");
        }

        function initializeGoogleAI() {
             // SDK Verfügbarkeit wird jetzt durch das Event sichergestellt
             if (!window.GoogleGenerativeAI || !window.HarmCategory || !window.HarmBlockThreshold) {
                 console.error("Google AI SDK Komponenten nicht global verfügbar.");
                 addErrorMessageToUI("Kritischer Fehler: Google AI Komponenten fehlen.", false);
                 updateStatus("Fehler: AI nicht initialisiert");
                 setSendButtonState(false); // Deaktivieren
                 return;
             }

             if (settings.apiKey) {
                 try {
                     genAI = new window.GoogleGenerativeAI(settings.apiKey);
                     updateCurrentModelInstance(); // Holt das Modell basierend auf Settings
                     console.log(`Google AI Initialized. Ready to use model: ${settings.model}`);
                     updateStatus("Bereit");
                     setSendButtonState(true); // Aktivieren
                 } catch (error) {
                     console.error("Error initializing Google AI:", error);
                     addErrorMessageToUI(`Fehler bei der Initialisierung von Google AI: ${error.message}. Prüfen Sie Ihren API-Schlüssel.`, false);
                     updateStatus("Fehler: AI Initialisierung");
                     setSendButtonState(false); // Deaktivieren
                     genAI = null;
                     currentModel = null;
                 }
             } else {
                 console.warn("API Key missing. Cannot initialize Google AI.");
                 addErrorMessageToUI("Kein API-Schlüssel konfiguriert. Bitte in den Einstellungen eingeben.", false);
                 updateStatus("Fehler: API Schlüssel fehlt");
                 setSendButtonState(false); // Deaktivieren
                 genAI = null;
                 currentModel = null;
             }
         }

         // Hilfsfunktion, um die Modellinstanz zu aktualisieren
         function updateCurrentModelInstance() {
             if (!genAI) return; // Nicht initialisiert
             try {
                 currentModel = genAI.getGenerativeModel({
                     model: settings.model,
                     generationConfig: getGenerationConfig(),
                     safetySettings: getSafetySettings(), // Safety Settings jetzt anwenden
                     systemInstruction: settings.systemPrompt || undefined // System Prompt anwenden
                 });
                 console.log(`Model instance updated to: ${settings.model}`);
                  setSendButtonState(true); // Aktivieren falls vorher deaktiviert
             } catch (error) {
                 console.error(`Error getting model instance for ${settings.model}:`, error);
                 addErrorMessageToUI(`Fehler beim Laden des Modells ${settings.model}: ${error.message}`, false);
                 updateStatus(`Fehler: Modell ${settings.model}`);
                 currentModel = null; // Zurücksetzen
                 setSendButtonState(false); // Deaktivieren
             }
         }

         // Setzt den Zustand des Senden/Bild Buttons
         function setSendButtonState(enabled) {
             sendButton.disabled = !enabled;
             imageUploadButton.disabled = !enabled;
         }


        // --- Event Listener Setup ---
        function setupEventListeners() {
            sendButton.addEventListener('click', handleSend);
            promptInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); handleSend();
                }
            });
            promptInput.addEventListener('input', autoResizeTextarea);

            settingsButton.addEventListener('click', openSettingsModal);
            closeSettingsButton.addEventListener('click', closeSettingsModal);
            window.addEventListener('click', (event) => { if (event.target === settingsModal) closeSettingsModal(); });
            saveSettingsButton.addEventListener('click', handleSaveSettings);
            toggleApiKeyButton.addEventListener('click', toggleApiKeyVisibility);

            newChatButton.addEventListener('click', () => createNewChat(true)); // Immer rendern & auswählen
            clearHistoryButton.addEventListener('click', handleClearHistory);

            // Bild-Upload
            imageUploadButton.addEventListener('click', () => imageUploadInput.click());
            imageUploadInput.addEventListener('change', handleImageUpload);

            // Event Delegation für History Items
            historyList.addEventListener('click', handleHistoryClick);

             // Live Slider Updates
             temperatureSlider.addEventListener('input', () => temperatureValue.textContent = temperatureSlider.value);
             maxOutputTokensSlider.addEventListener('input', () => maxOutputTokensValue.textContent = maxOutputTokensSlider.value);
             topPSlider.addEventListener('input', () => topPValue.textContent = topPSlider.value);
             topKSlider.addEventListener('input', () => topKValue.textContent = topKSlider.value);

             // Stop Button
             stopButton.addEventListener('click', stopGeneration);
        }

        // --- Chat Funktionen ---
        function handleSend() {
            const promptText = promptInput.value.trim();
            const imagePart = window.uploadedImagePart; // Prüfen ob ein Bild hochgeladen wurde

            if ((!promptText && !imagePart) || isGenerating || !currentModel) {
                 if (!currentModel && settings.apiKey) {
                     addErrorMessageToUI("Modell konnte nicht geladen werden. Prüfen Sie die Einstellungen und den API-Schlüssel.");
                 } else if (!settings.apiKey) {
                     addErrorMessageToUI("Kein API-Schlüssel konfiguriert.");
                 }
                 return;
             }

            // Wenn kein Chat aktiv ist, automatisch neuen erstellen
            if (!currentChatId) {
                createNewChat(false); // Nicht sofort rendern/auswählen
            }

            // Nachricht für die UI vorbereiten (kann Text und/oder Bild enthalten)
            const userMessageParts = [];
            if (imagePart) {
                 userMessageParts.push(imagePart);
                 window.uploadedImagePart = null; // Bild nach dem Senden zurücksetzen
                 // UI braucht eine Möglichkeit, das Bild anzuzeigen
             }
            if (promptText) {
                userMessageParts.push({ text: promptText });
            }

            // Füge die kombinierte Nachricht zur UI hinzu
            addMessageToUI(userMessageParts, 'user');

            // Füge die Nachricht zur Konversation hinzu
            currentConversation.push({ role: 'user', parts: userMessageParts });

            // Input leeren und UI aktualisieren
            promptInput.value = '';
            autoResizeTextarea();
            updateChatHistory(currentChatId, null, currentConversation); // Nachrichten speichern
            // estimateAndDisplayTokenCount(); // Token Count aktualisieren

            // Sende an die API
            sendMessageToGemini();
        }

        async function sendMessageToGemini() {
            if (!currentModel) {
                addErrorMessageToUI("Google AI ist nicht initialisiert oder Modell fehlt. Prüfen Sie die Einstellungen.");
                return;
            }

            isGenerating = true;
            showLoading(true);
            updateStatus("Generiere Antwort...");
            controller = new AbortController();
            const signal = controller.signal;

            try {
                // Filtere leere Nachrichten oder Nachrichten ohne gültige 'parts', bevor sie gesendet werden
                const historyForAPI = currentConversation
                    .filter(msg => msg.parts && Array.isArray(msg.parts) && msg.parts.length > 0)
                    .slice(0, -1); // Alles außer der letzten User-Nachricht

                const chat = currentModel.startChat({
                    history: historyForAPI,
                    generationConfig: getGenerationConfig(),
                    safetySettings: getSafetySettings(),
                     systemInstruction: settings.systemPrompt || undefined // Wird jetzt in der Modellinstanz gesetzt
                });

                const lastUserMessageParts = currentConversation[currentConversation.length - 1].parts;

                const result = await chat.sendMessageStream(lastUserMessageParts, { signal });

                let aiResponseText = "";
                const aiMessageElement = addMessageToUI([{ text: "" }], 'ai', true); // Leere Nachricht für Streaming

                for await (const chunk of result.stream) {
                     if (signal.aborted) {
                        console.log("Generation stopped by user.");
                        aiResponseText += "\n\n*(Generierung gestoppt)*";
                         // Update final text content
                        const contentElement = aiMessageElement.querySelector('.message-content');
                         if (contentElement) contentElement.textContent = aiResponseText;
                         break;
                    }

                     try {
                        const chunkText = chunk.text();
                        aiResponseText += chunkText;
                         // Update UI smoothly
                         const contentElement = aiMessageElement.querySelector('.message-content');
                         if (contentElement) contentElement.textContent = aiResponseText;
                         chatWindow.scrollTop = chatWindow.scrollHeight;
                    } catch (error) {
                        console.warn("Could not get text from chunk:", error);
                         // Check if it's a safety block
                         if (chunk.promptFeedback?.blockReason) {
                            console.error("Blocked:", chunk.promptFeedback.blockReason);
                            aiResponseText += `\n\n*(Inhalt blockiert: ${chunk.promptFeedback.blockReason})*`;
                             const contentElement = aiMessageElement.querySelector('.message-content');
                             if (contentElement) contentElement.textContent = aiResponseText;
                             addErrorMessageToUI(`Antwort blockiert wegen: ${chunk.promptFeedback.blockReason}. Passen Sie ggf. die Sicherheitseinstellungen an.`);
                             break; // Stop processing this response
                         }
                         if (signal.aborted) break;
                    }
                }


                // Handle potential finish reason if not aborted
                 if (!signal.aborted && result.response) {
                     const finalResponse = await result.response; // Wait for the aggregated response
                     if (finalResponse.promptFeedback?.blockReason) {
                         console.error("Final response blocked:", finalResponse.promptFeedback.blockReason);
                         if (!aiResponseText.includes("blockiert")) { // Avoid duplicate messages
                             aiResponseText += `\n\n*(Inhalt blockiert: ${finalResponse.promptFeedback.blockReason})*`;
                             const contentElement = aiMessageElement.querySelector('.message-content');
                             if (contentElement) contentElement.textContent = aiResponseText;
                              addErrorMessageToUI(`Antwort blockiert wegen: ${finalResponse.promptFeedback.blockReason}. Passen Sie ggf. die Sicherheitseinstellungen an.`);
                         }
                     } else {
                         // Nur speichern, wenn nicht blockiert oder gestoppt
                         currentConversation.push({ role: 'model', parts: [{ text: aiResponseText }] });

                         if (currentConversation.length === 2) { // Erster Austausch
                             const userFirstPart = currentConversation[0].parts.find(p => p.text)?.text || "Bildnachricht";
                             const newTitle = generateChatTitle(userFirstPart);
                             updateChatHistory(currentChatId, newTitle, currentConversation);
                             renderHistoryList();
                         } else {
                             updateChatHistory(currentChatId, null, currentConversation);
                         }
                         // estimateAndDisplayTokenCount(); // Token Count aktualisieren
                     }
                 } else if(signal.aborted) {
                    // Conversation wurde nicht geupdated, Text im UI enthält Stop-Hinweis
                 }


            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log("Generation aborted successfully via controller.");
                     // Nachricht im UI hat schon den Stop-Hinweis
                } else {
                    console.error("Error sending message to Gemini:", error);
                    addErrorMessageToUI(`Fehler von Gemini: ${error.message}`);
                    // Fehler nicht zur Conversation hinzufügen
                }
            } finally {
                isGenerating = false;
                showLoading(false);
                updateStatus("Bereit");
                controller = null;
            }
        }

        function stopGeneration() {
            if (controller) {
                controller.abort();
                console.log("Stop button clicked, aborting generation...");
                isGenerating = false; // Zustand sofort ändern
                showLoading(false); // UI sofort aktualisieren
                updateStatus("Generierung gestoppt");
            }
        }

         function addMessageToUI(parts, sender, isEmptyForStreaming = false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', `${sender}-message`);

            // Entferne ggf. alte Typing-Indikatoren
            const existingTyping = chatWindow.querySelector('.typing-indicator.ai-message');
            if (existingTyping) existingTyping.remove();

            const avatar = document.createElement('div');
            avatar.classList.add('message-avatar');
             let avatarIcon = '';
             if (sender === 'user') avatarIcon = 'fa-user';
             else if (sender === 'ai') avatarIcon = 'fa-robot';
             else if (sender === 'error') avatarIcon = 'fa-exclamation-triangle';
             avatar.innerHTML = `<i class="fas ${avatarIcon}"></i>`;

             const contentWrapper = document.createElement('div');
             contentWrapper.classList.add('message-content-wrapper');

             const contentDiv = document.createElement('div');
             contentDiv.classList.add('message-content');

             if (!isEmptyForStreaming) {
                 parts.forEach(part => {
                     if (part.text) {
                         // Erstelle ein Text-Element (oder füge Text hinzu, wenn schon vorhanden)
                         // Wichtig: Benutze textContent für Sicherheit gegen XSS
                         const textNode = document.createTextNode(part.text);
                         contentDiv.appendChild(textNode);
                     } else if (part.inlineData) {
                         // Erstelle ein Bild-Element
                         const img = document.createElement('img');
                         img.src = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                         img.alt = "Hochgeladenes Bild";
                         contentDiv.appendChild(img); // Füge das Bild hinzu
                     }
                 });
                 // Fallback für leere User-Nachricht (z.B. nur Bild gesendet)
                  if (sender === 'user' && contentDiv.childNodes.length === 0) {
                      contentDiv.textContent = "(Bild gesendet)";
                      contentDiv.style.fontStyle = 'italic';
                      contentDiv.style.color = 'var(--secondary-color)';
                  }
             } else {
                 contentDiv.textContent = '...'; // Platzhalter für Streaming
             }

             contentWrapper.appendChild(contentDiv);

             if (sender === 'user') {
                 messageDiv.appendChild(contentWrapper);
                 messageDiv.appendChild(avatar);
             } else {
                 messageDiv.appendChild(avatar);
                 messageDiv.appendChild(contentWrapper);
             }

             if (sender === 'error') {
                 messageDiv.classList.remove('ai-message');
                 messageDiv.classList.add('error-message');
             }

             chatWindow.appendChild(messageDiv);

             if (!isEmptyForStreaming) {
                 chatWindow.scrollTop = chatWindow.scrollHeight;
             }
             return messageDiv; // Wichtig für Streaming-Update
         }


         function addErrorMessageToUI(text, doScroll = true) {
             // Vermeide doppelte Fehlermeldungen kurz nacheinander
             const lastMessage = chatWindow.querySelector('.message:last-child');
             if (lastMessage && lastMessage.classList.contains('error-message') && lastMessage.textContent.includes(text.substring(0, 30))) {
                 console.warn("Duplicate error message suppressed:", text);
                 return;
             }
             addMessageToUI([{ text: text }], 'error'); // Fehler haben nur Text
             if (doScroll) {
                chatWindow.scrollTop = chatWindow.scrollHeight;
             }
             updateStatus("Fehler");
         }


        function showLoading(isLoading) {
             setSendButtonState(!isLoading); // Deaktiviert Senden/Bild bei isLoading=true
             promptInput.disabled = isLoading;

             if (isLoading) {
                 stopButton.style.display = 'flex';
                 sendButton.style.display = 'none';
                 imageUploadButton.style.display = 'none'; // Bild-Upload während Generierung ausblenden

                 // Visuellen Indikator hinzufügen
                 const typingDiv = document.createElement('div');
                 typingDiv.classList.add('message', 'ai-message', 'typing-indicator'); // Reuse styling
                 typingDiv.style.opacity = 1;
                 typingDiv.innerHTML = `
                     <div class="message-avatar"><i class="fas fa-robot"></i></div>
                     <div class="message-content-wrapper">
                        <div class="message-content" style="background: transparent; padding: 8px 0;">
                             <span style="animation-delay: -0.32s;"></span>
                             <span style="animation-delay: -0.16s;"></span>
                             <span></span>
                         </div>
                     </div>
                 `;
                 chatWindow.appendChild(typingDiv);
                 chatWindow.scrollTop = chatWindow.scrollHeight;

             } else {
                 stopButton.style.display = 'none';
                 sendButton.style.display = 'flex';
                 imageUploadButton.style.display = 'flex'; // Bild-Upload wieder anzeigen

                 // Entferne Ladeindikatoren
                 const typingIndicator = chatWindow.querySelector('.typing-indicator.ai-message');
                 if (typingIndicator) typingIndicator.remove();
             }
        }

         // --- Bildverarbeitung ---
         function handleImageUpload(event) {
             const file = event.target.files[0];
             if (!file) return;

             // Prüfe Dateityp (nur erlaubte Typen)
             const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif'];
             if (!allowedTypes.includes(file.type)) {
                 addErrorMessageToUI(`Ungültiger Bildtyp: ${file.type}. Erlaubt sind JPEG, PNG, WEBP, HEIC, HEIF.`);
                 imageUploadInput.value = ''; // Input zurücksetzen
                 return;
             }

             const reader = new FileReader();
             reader.onloadend = () => {
                 const base64Data = reader.result.split(',')[1]; // Nur Base64-Teil
                 window.uploadedImagePart = {
                     inlineData: {
                         mimeType: file.type,
                         data: base64Data
                     }
                 };
                 console.log("Bild vorbereitet:", file.name, file.type);
                 // Optional: Vorschau anzeigen oder Hinweis geben
                 promptInput.placeholder = `Bild '${file.name}' hinzugefügt. Text hinzufügen oder senden...`;
                 promptInput.focus();
             };
             reader.onerror = (error) => {
                  console.error("Fehler beim Lesen der Bilddatei:", error);
                  addErrorMessageToUI("Fehler beim Verarbeiten des Bildes.");
                  window.uploadedImagePart = null;
                  imageUploadInput.value = '';
             };
             reader.readAsDataURL(file);
              imageUploadInput.value = ''; // Input für nächsten Upload zurücksetzen
         }

        // --- History Management ---
         function generateChatTitle(firstMessageText) {
             // Nimmt die ersten paar Wörter für den Titel
             const words = firstMessageText.split(' ');
             return words.slice(0, 5).join(' ') + (words.length > 5 ? '...' : '');
         }

         function createNewChat(renderAndSelect = true) {
             const newChat = {
                 id: `chat-${Date.now()}`,
                 title: "Neuer Chat",
                 messages: [] // Startet leer
             };
             chatHistory.unshift(newChat);
             currentChatId = newChat.id;
             currentConversation = newChat.messages; // Wichtig: Referenz auf messages-Array des neuen Chats
             saveHistory();

             if (renderAndSelect) {
                 renderHistoryList();
                 selectChat(newChat.id);
                 promptInput.focus();
             }
             window.uploadedImagePart = null; // Sicherstellen, dass kein altes Bild hängt
             // estimateAndDisplayTokenCount(); // Token Count zurücksetzen
         }

         function selectChat(chatId) {
             if (!chatId) { // Fallback für leeren Zustand
                 chatWindow.innerHTML = `
                     <div class="message ai-message">
                         <div class="message-avatar"><i class="fas fa-robot"></i></div>
                         <div class="message-content-wrapper"><div class="message-content">
                             Willkommen im MinoGPT Studio! Starten Sie einen neuen Chat oder wählen Sie einen aus dem Verlauf.
                         </div></div>
                     </div>`;
                 currentChatId = null;
                 currentConversation = [];
                 promptInput.value = '';
                 promptInput.placeholder = 'Ihre Anfrage an MinoGPT...';
                 autoResizeTextarea();
                 setActiveHistoryItem(null);
                 window.uploadedImagePart = null;
                 // estimateAndDisplayTokenCount();
                 return;
             }

             const selectedChat = chatHistory.find(chat => chat.id === chatId);
             if (selectedChat) {
                 currentChatId = chatId;
                 // WICHTIG: Kopie erstellen, um unbeabsichtigte Änderungen am Original zu vermeiden?
                 // Nein, wir wollen die Referenz, damit push() direkt die History updated.
                 currentConversation = selectedChat.messages;
                 chatWindow.innerHTML = ''; // Leeren

                 // Nachrichten rendern (können jetzt Bilder enthalten)
                 currentConversation.forEach(msg => addMessageToUI(msg.parts, msg.role));

                 chatWindow.scrollTop = chatWindow.scrollHeight;
                 promptInput.value = '';
                  promptInput.placeholder = 'Ihre Anfrage an MinoGPT...';
                 autoResizeTextarea();
                 promptInput.focus();
                 setActiveHistoryItem(chatId);
                 window.uploadedImagePart = null;
                 // estimateAndDisplayTokenCount(); // Token Count für geladenen Chat berechnen
             }
         }

          function handleHistoryClick(event) {
             const target = event.target;
             const historyItem = target.closest('.history-item');
             const deleteButton = target.closest('.delete-chat-btn');

             if (deleteButton && historyItem) {
                 event.stopPropagation();
                 const chatId = historyItem.dataset.chatId;
                 const chatTitle = historyItem.querySelector('.history-title')?.textContent || "diesen Chat";
                 if (confirm(`Möchten Sie "${chatTitle}" wirklich löschen?`)) {
                     deleteChat(chatId);
                 }
             } else if (historyItem) {
                 const chatId = historyItem.dataset.chatId;
                 // Nur auswählen, wenn nicht schon aktiv, um unnötiges Neuladen zu vermeiden
                 if (chatId !== currentChatId) {
                    selectChat(chatId);
                 }
             }
         }

         function deleteChat(chatId) {
             chatHistory = chatHistory.filter(chat => chat.id !== chatId);
             saveHistory();
             renderHistoryList(); // Liste neu rendern

             if (currentChatId === chatId) {
                 const nextChatId = chatHistory.length > 0 ? chatHistory[0].id : null;
                 selectChat(nextChatId); // Nächsten oder leeren Zustand auswählen
             }
         }

         function renderHistoryList() {
             historyList.innerHTML = ''; // Liste leeren
             chatHistory.forEach(chat => {
                 const li = document.createElement('li');
                 li.classList.add('history-item');
                 li.dataset.chatId = chat.id;
                 if (chat.id === currentChatId) {
                     li.classList.add('active');
                 }

                 const icon = document.createElement('i');
                 icon.className = 'fas fa-comment-dots';

                 const titleSpan = document.createElement('span');
                 titleSpan.classList.add('history-title');
                 titleSpan.textContent = chat.title || "Unbenannter Chat";

                 const deleteBtn = document.createElement('button');
                 deleteBtn.className = 'delete-chat-btn';
                 deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
                 deleteBtn.title = 'Chat löschen';

                 li.appendChild(icon);
                 li.appendChild(titleSpan);
                 li.appendChild(deleteBtn);
                 historyList.appendChild(li);
             });
         }

          function setActiveHistoryItem(chatId) {
             const activeItem = historyList.querySelector('.active');
             if (activeItem) activeItem.classList.remove('active');
             if (chatId) {
                 const newActiveItem = historyList.querySelector(`[data-chat-id="${chatId}"]`);
                 if (newActiveItem) newActiveItem.classList.add('active');
             }
         }


        function handleClearHistory() {
             if (confirm("Möchten Sie wirklich den gesamten Chatverlauf löschen? Dies kann nicht rückgängig gemacht werden.")) {
                 chatHistory = [];
                 currentChatId = null;
                 currentConversation = [];
                 saveHistory();
                 renderHistoryList();
                 selectChat(null); // Leeren Zustand anzeigen
             }
         }


        // --- Local Storage für History & Settings ---
        function saveHistory() { try { localStorage.setItem('minoGptChatHistory_v2', JSON.stringify(chatHistory)); } catch (e) { console.error("LS Error saving history:", e); addErrorMessageToUI("Fehler beim Speichern des Verlaufs."); }}
        function loadHistory() {
            const storedHistory = localStorage.getItem('minoGptChatHistory_v2');
            if (storedHistory) { try { chatHistory = JSON.parse(storedHistory); } catch (e) { console.error("LS Error parsing history:", e); chatHistory = []; localStorage.removeItem('minoGptChatHistory_v2'); } }
            else { chatHistory = []; }
        }
        function updateChatHistory(chatId, newTitle, messages) {
            const chatIndex = chatHistory.findIndex(chat => chat.id === chatId);
            if (chatIndex !== -1) {
                 if (newTitle) chatHistory[chatIndex].title = newTitle;
                 chatHistory[chatIndex].messages = messages; // Direkte Referenz sorgt für Update
                 saveHistory();
            }
        }

        function saveSettings() {
            // Safety Settings sammeln
             const safetySettingsData = {};
             Object.keys(safetySelectors).forEach(category => {
                 safetySettingsData[category] = safetySelectors[category].value;
             });

             settings = {
                 apiKey: apiKeyInput.value.trim(),
                 model: modelSelect.value,
                 temperature: parseFloat(temperatureSlider.value),
                 maxOutputTokens: parseInt(maxOutputTokensSlider.value, 10),
                 topP: parseFloat(topPSlider.value),
                 topK: parseInt(topKSlider.value, 10),
                 systemPrompt: systemPromptInput.value.trim(),
                 safetySettings: safetySettingsData // Gesammelte Safety Settings
             };
             try { localStorage.setItem('minoGptSettings_v2', JSON.stringify(settings)); console.log("Settings saved:", settings); }
             catch (e) { console.error("LS Error saving settings:", e); addErrorMessageToUI("Fehler beim Speichern der Einstellungen."); }
        }

         function loadSettings() {
             const storedSettings = localStorage.getItem('minoGptSettings_v2');
             const defaultSafety = {
                 "HARM_CATEGORY_HARASSMENT": "BLOCK_MEDIUM_AND_ABOVE",
                 "HARM_CATEGORY_HATE_SPEECH": "BLOCK_MEDIUM_AND_ABOVE",
                 "HARM_CATEGORY_SEXUALLY_EXPLICIT": "BLOCK_MEDIUM_AND_ABOVE",
                 "HARM_CATEGORY_DANGEROUS_CONTENT": "BLOCK_MEDIUM_AND_ABOVE"
             };

             if (storedSettings) {
                 try {
                     settings = JSON.parse(storedSettings);
                     // Set defaults for potentially missing keys
                     settings.model = settings.model || 'gemini-1.5-flash-latest';
                     settings.temperature = settings.temperature ?? 0.7; // Nullish coalescing
                     settings.maxOutputTokens = settings.maxOutputTokens || 2048;
                     settings.topP = settings.topP ?? 0.95;
                     settings.topK = settings.topK || 40;
                     settings.systemPrompt = settings.systemPrompt || '';
                     settings.safetySettings = settings.safetySettings || defaultSafety;
                      // Ensure all safety categories exist
                      Object.keys(defaultSafety).forEach(key => {
                         if (!settings.safetySettings[key]) {
                             settings.safetySettings[key] = defaultSafety[key];
                         }
                     });

                 } catch(e) {
                     console.error("LS Error parsing settings:", e);
                     setDefaultSettings();
                     localStorage.removeItem('minoGptSettings_v2');
                 }
             } else {
                 setDefaultSettings();
             }
         }

         function setDefaultSettings() {
             const defaultSafety = {
                 "HARM_CATEGORY_HARASSMENT": "BLOCK_MEDIUM_AND_ABOVE",
                 "HARM_CATEGORY_HATE_SPEECH": "BLOCK_MEDIUM_AND_ABOVE",
                 "HARM_CATEGORY_SEXUALLY_EXPLICIT": "BLOCK_MEDIUM_AND_ABOVE",
                 "HARM_CATEGORY_DANGEROUS_CONTENT": "BLOCK_MEDIUM_AND_ABOVE"
             };
             settings = {
                 apiKey: '', // Bleibt leer, initApp füllt ggf. Demo Key
                 model: 'gemini-1.5-flash-latest',
                 temperature: 0.7,
                 maxOutputTokens: 2048,
                 topP: 0.95,
                 topK: 40,
                 systemPrompt: '',
                 safetySettings: defaultSafety
             };
             console.log("Default settings applied.");
         }